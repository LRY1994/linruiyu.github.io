
 <!DOCTYPE HTML>
<html lang="zh-hk">
<head>
  <meta charset="UTF-8">
  
    <title>圆玉的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Ruiyu Lin">
    

    
    <meta name="description" content="林瑞玉的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="圆玉的博客">
<meta property="og:url" content="http://lry1994.github.io/page/5/index.html">
<meta property="og:site_name" content="圆玉的博客">
<meta property="og:description" content="林瑞玉的博客">
<meta property="og:locale" content="zh-hk">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="圆玉的博客">
<meta name="twitter:description" content="林瑞玉的博客">

    
    <link rel="alternative" href="/atom.xml" title="圆玉的博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="圆玉的博客" title="圆玉的博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="圆玉的博客">圆玉的博客</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:lry1994.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/study/Comprehensive/load-process.html" title="页面加载过程解析" itemprop="url">页面加载过程解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Ruiyu Lin" target="_blank" itemprop="author">Ruiyu Lin</a>
		
  <p class="article-time">
    <time datetime="2017-10-11T16:00:00.000Z" itemprop="datePublished"> Published 2017-10-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="页面加载"><a href="#页面加载" class="headerlink" title="页面加载"></a>页面加载</h1><p>页面加载就是从你输入网址+enter开始，发生的一些列过程，最终到页面显示。 从微观上分的话，页面加载有两部分</p>
<p>一个是以<code>DOMContentLoaded</code>触发为标志的DOM树的渲染完成</p>
<p>一个是以辅助资源img,font加载完成为触发标志的onload事件</p>
<p>他们两个的具体区别就是<code>&quot;资源的加载&quot;</code>这个关键点.</p>
<p>在获得数据响应后,页面开始解析,发生的过程为:</p>
<ol>
<li>解析HTML结构。 </li>
<li>加载外部脚本和样式表文件。 </li>
<li>解析并执行脚本代码。 </li>
<li>构造HTML DOM模型。//ready执行 </li>
<li>加载图片等外部文件。 </li>
<li>页面加载完毕。//load执行</li>
</ol>
<p>上文的页面加载其实只算是 </p>
<p><code>浏览器处理</code>=&gt; <code>最后onload</code>  这一过程</p>
<p>从你输入网站 + enter键后，发生的过程为:</p>
<p><code>重定向</code>=&gt;<code>检查DNS缓存</code>=&gt; <code>DNS解析</code> =&gt; <code>TCP连接</code> =&gt; <code>发请求</code>=&gt; <code>得到响应</code>=&gt; <code>浏览器处理</code> =&gt; <code>最后onload</code></p>
<h2 id="宏观页面加载"><a href="#宏观页面加载" class="headerlink" title="宏观页面加载"></a>宏观页面加载</h2><p>以前，我们来检查浏览器的时候，大部分情况下是使用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(specialNum);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(specialNum);</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="built_in">Date</span>.now();</span><br></pre></td></tr></table></figure></p>
<p>上面说的两种方法， 获取的精度都是<code>毫秒级(10^-6)</code></p>
<p>ES5提出的<code>performance</code>可以获取到，<code>微秒级别(10^-9)</code></p>
<p><code>performance.timing</code>对象<br><img src="/study/Comprehensive/load-process/timing.png"></p>
<p> <a href="https://www.cnblogs.com/libin-1/p/6501951.html" target="_blank" rel="noopener">https://www.cnblogs.com/libin-1/p/6501951.html</a></p>
<p>比如，我们获得重定向时间用:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> time = performance.timing;</span><br><span class="line"><span class="keyword">var</span> redirect = time.redirectEnd - time.redirectStart; <span class="comment">//单位为微秒</span></span><br><span class="line">DOMContentLoaded事件 是在domContentLoaded那段触发的。图中所指的domContentLoaded其实分为两块, 一个是domContentLoadedEventStart和domContentLoadedEventEnd. 详见下述说明:</span><br><span class="line"><span class="comment">// 获取 performance 数据</span></span><br><span class="line"><span class="keyword">var</span> performance = &#123;</span><br><span class="line">    <span class="comment">// memory 是非标准属性，只在 Chrome 有</span></span><br><span class="line">    <span class="comment">// 财富问题：我有多少内存</span></span><br><span class="line">    memory: &#123;</span><br><span class="line">        usedJSHeapSize:  <span class="number">16100000</span>, <span class="comment">// JS 对象（包括V8引擎内部对象）占用的内存，一定小于 totalJSHeapSize</span></span><br><span class="line">        totalJSHeapSize: <span class="number">35100000</span>, <span class="comment">// 可使用的内存</span></span><br><span class="line">        jsHeapSizeLimit: <span class="number">793000000</span> <span class="comment">// 内存大小限制</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  哲学问题：我从哪里来？</span></span><br><span class="line">    navigation: &#123;</span><br><span class="line">        redirectCount: <span class="number">0</span>, <span class="comment">// 如果有重定向的话，页面通过几次重定向跳转而来</span></span><br><span class="line">        type: <span class="number">0</span>           <span class="comment">// 0   即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等）</span></span><br><span class="line">                          <span class="comment">// 1   即 TYPE_RELOAD       通过 window.location.reload() 刷新的页面</span></span><br><span class="line">                          <span class="comment">// 2   即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录）</span></span><br><span class="line">                          <span class="comment">// 255 即 TYPE_UNDEFINED    非以上方式进入的页面</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    timing: &#123;</span><br><span class="line">        <span class="comment">// 在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）unload 的时间戳，如果无前一个网页 unload ，则与 fetchStart 值相等</span></span><br><span class="line">        navigationStart: <span class="number">1441112691935</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0</span></span><br><span class="line">        unloadEventStart: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和 unloadEventStart 相对应，返回前一个网页 unload 事件绑定的回调函数执行完毕的时间戳</span></span><br><span class="line">        unloadEventEnd: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0 </span></span><br><span class="line">        redirectStart: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0 </span></span><br><span class="line">        redirectEnd: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前</span></span><br><span class="line">        fetchStart: <span class="number">1441112692155</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等</span></span><br><span class="line">        domainLookupStart: <span class="number">1441112692155</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等</span></span><br><span class="line">        domainLookupEnd: <span class="number">1441112692155</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 fetchStart 值相等</span></span><br><span class="line">        <span class="comment">// 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间</span></span><br><span class="line">        connectStart: <span class="number">1441112692155</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等</span></span><br><span class="line">        <span class="comment">// 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间</span></span><br><span class="line">        <span class="comment">// 注意这里握手结束，包括安全连接建立完成、SOCKS 授权通过</span></span><br><span class="line">        connectEnd: <span class="number">1441112692155</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HTTPS 连接开始的时间，如果不是安全连接，则值为 0</span></span><br><span class="line">        secureConnectionStart: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存</span></span><br><span class="line">        <span class="comment">// 连接错误重连时，这里显示的也是新建立连接的时间</span></span><br><span class="line">        requestStart: <span class="number">1441112692158</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存</span></span><br><span class="line">        responseStart: <span class="number">1441112692686</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存</span></span><br><span class="line">        responseEnd: <span class="number">1441112692687</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件</span></span><br><span class="line">        domLoading: <span class="number">1441112692690</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件</span></span><br><span class="line">        <span class="comment">// 注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源</span></span><br><span class="line">        domInteractive: <span class="number">1441112693093</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DOM 解析完成后，网页内资源加载开始的时间</span></span><br><span class="line">        <span class="comment">// 在 DOMContentLoaded 事件抛出前发生</span></span><br><span class="line">        domContentLoadedEventStart: <span class="number">1441112693093</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）</span></span><br><span class="line">        domContentLoadedEventEnd: <span class="number">1441112693101</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件</span></span><br><span class="line">        domComplete: <span class="number">1441112693214</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load 事件发送给文档，也即 load 回调函数开始执行的时间</span></span><br><span class="line">        <span class="comment">// 注意如果没有绑定 load 事件，值为 0</span></span><br><span class="line">        loadEventStart: <span class="number">1441112693214</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load 事件的回调函数执行完毕的时间</span></span><br><span class="line">        loadEventEnd: <span class="number">1441112693215</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>不过<code>performance</code>还有另外一个方法 <code>now</code></p>
<p><code>performance.now()</code></p>
<p>通常，我们会将该方法和<code>Date.now()</code>进行一个对比。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">performance.now();  <span class="comment">//输出是微秒级别</span></span><br><span class="line"><span class="built_in">Date</span>.now();  <span class="comment">//输出是毫秒级别</span></span><br></pre></td></tr></table></figure></p>
<p>其中<code>Date.now()</code>是输出 从<code>1970年</code>开始的毫秒数.</p>
<p><code>performance.now()</code>参考的是从<code></code>performance.timing.navigationStart<figure class="highlight plain"><figcaption><span>到现在的微秒数.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里，我们可以使用``performance.now()``来模拟获取``DomContentLoaded``的时间。</span><br><span class="line">```javascript</span><br><span class="line">var timesnipe = performance.now();</span><br><span class="line">        document.addEventListener(&apos;DOMContentLoaded&apos;, function() &#123;</span><br><span class="line">            console.log(performance.now() - timesnipe);</span><br><span class="line">        &#125;, false);</span><br><span class="line"></span><br><span class="line">        window.addEventListener(&apos;load&apos;, function() &#123;</span><br><span class="line">           console.log(performance.now() - timesnipe);</span><br><span class="line">        &#125;, false);</span><br><span class="line">//但是这样并不等同于,只能算作约等于</span><br><span class="line">performance.timing.domContentLoadedEventStart - performance.timing.domLoading; //检测domLoadEvent触发时间</span><br></pre></td></tr></table></figure></p>
<p>上面不相等的原因就在于，当执行script的时候，DOM其实已经开始解析DOM和页面内容， 所以会造成时间上比真实时间<code>略短</code>。</p>
<h2 id="redirect"><a href="#redirect" class="headerlink" title="redirect"></a>redirect</h2><p>这是页面加载的第一步(也有可能没有). 比如，当一个页面已经迁移，但是你输入原来的网站地址的时候就会发生。 </p>
<p>或者， 比如<code>example.com</code> -&gt;<code>m.example.com/home</code>。</p>
<p>这里就会经过两次DNS解析，TCP连接，以及请求的发送,耗费的时间成本是双倍的。所以，<code>在后台设置好正确的网址是很重要的。</code><br> <img src="/study/Comprehensive/load-process/2.png"></p>
<p>这里，我们可以使用<code>performance</code>的属性,计算出<code>重定向时间</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redirectTime = redirectEnd - redirectStart</span><br></pre></td></tr></table></figure>
<h2 id="cache-DNS-TCP-Request-Response"><a href="#cache-DNS-TCP-Request-Response" class="headerlink" title="cache,DNS,TCP,Request,Response"></a>cache,DNS,TCP,Request,Response</h2><p>如果我们的域名输入正确的话，接着，浏览器会查询本地是否有域名缓存(appCache)，如果有，则不需要进行DNS解析，否则需要对域名进行解析，找到真实的IP地址，然后建立3次握手连接， 发送请求， 最后接受数据。 通常，这一部分，可以做的优化有:</p>
<p>发送请求的优化:加异地机房，加CDN.(加快解析request)</p>
<p>请求加载数据的优化:页面内容经过 gzip 压缩，静态资源 css/js 等压缩(request到response的优化)</p>
<p>ok~ 使用performance测试时间为:</p>
<p>DNS查询耗时 = domainLookupEnd - domainLookupStart</p>
<p>TCP链接耗时 = connectEnd - connectStart</p>
<p>request请求耗时 = responseEnd - responseStart</p>
<p>解析dom树耗时 = domComplete - domInteractive</p>
<p>白屏时间 = domloadng - fetchStart</p>
<p>domready时间 = domContentLoadedEventEnd - fetchStart</p>
<p>onload时间 = loadEventEnd - fetchStart</p>
<p>其实，只要对照第一个图查查就可以，不用太关注上面的式子。使用时需要注意，<code>performance的相关操作，最好放在onload的回调中执行，避免出现异常的bug.</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    handleAddListener(<span class="string">'load'</span>, getTiming)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleAddListener</span>(<span class="params">type, fn</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">            <span class="built_in">window</span>.addEventListener(type, fn)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">window</span>.attachEvent(<span class="string">'on'</span> + type, fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getTiming</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> time = performance.timing;</span><br><span class="line">            <span class="keyword">var</span> timingObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> loadTime = (time.loadEventEnd - time.loadEventStart) / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(loadTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    getTiming();</span><br><span class="line">                &#125;, <span class="number">200</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            timingObj[<span class="string">'重定向时间'</span>] = (time.redirectEnd - time.redirectStart) / <span class="number">1000</span>;</span><br><span class="line">            timingObj[<span class="string">'DNS解析时间'</span>] = (time.domainLookupEnd - time.domainLookupStart) / <span class="number">1000</span>;</span><br><span class="line">            timingObj[<span class="string">'TCP完成握手时间'</span>] = (time.connectEnd - time.connectStart) / <span class="number">1000</span>;</span><br><span class="line">            timingObj[<span class="string">'HTTP请求响应完成时间'</span>] = (time.responseEnd - time.requestStart) / <span class="number">1000</span>;</span><br><span class="line">            timingObj[<span class="string">'DOM开始加载前所花费时间'</span>] = (time.responseEnd - time.navigationStart) / <span class="number">1000</span>;</span><br><span class="line">            timingObj[<span class="string">'DOM加载完成时间'</span>] = (time.domComplete - time.domLoading) / <span class="number">1000</span>;</span><br><span class="line">            timingObj[<span class="string">'DOM结构解析完成时间'</span>] = (time.domInteractive - time.domLoading) / <span class="number">1000</span>;</span><br><span class="line">            timingObj[<span class="string">'脚本加载时间'</span>] = (time.domContentLoadedEventEnd - time.domContentLoadedEventStart) / <span class="number">1000</span>;</span><br><span class="line">            timingObj[<span class="string">'onload事件时间'</span>] = (time.loadEventEnd - time.loadEventStart) / <span class="number">1000</span>;</span><br><span class="line">            timingObj[<span class="string">'页面完全加载时间'</span>] = (timingObj[<span class="string">'重定向时间'</span>] + timingObj[<span class="string">'DNS解析时间'</span>] + timingObj[<span class="string">'TCP完成握手时间'</span>] + timingObj[<span class="string">'HTTP请求响应完成时间'</span>] + timingObj[<span class="string">'DOM结构解析完成时间'</span>] + timingObj[<span class="string">'DOM加载完成时间'</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(item <span class="keyword">in</span> timingObj) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(item + <span class="string">":"</span> + timingObj[item] + <span class="string">'毫秒(ms)'</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">console</span>.log(performance.timing);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(timingObj)</span><br><span class="line">            <span class="built_in">console</span>.log(performance.timing);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<h2 id="process-onload"><a href="#process-onload" class="headerlink" title="process,onload"></a>process,onload</h2><p>这里的过程其实就和开头的时候说的一样</p>
<ol>
<li>解析HTML结构。 </li>
<li>加载外部脚本和样式表文件。 </li>
<li>解析并执行脚本代码。 </li>
<li>构造HTML DOM模型。//ready执行 </li>
<li>加载图片等外部文件。 </li>
<li>页面加载完毕。//load执行</li>
</ol>
<p>ok~ 这里，我们来计算一下时间:<br>上performance<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算DOMContentLoaded触发时间</span></span><br><span class="line"><span class="keyword">var</span> contentLoadedTime = t.domContentLoadedEventStart-t.domLoading</span><br><span class="line"><span class="comment">//计算load触发时间</span></span><br><span class="line"><span class="keyword">var</span> loadTime = t.domComplete - t.domLoading;</span><br></pre></td></tr></table></figure></p>
<p>DOMContentLoaded事件比onload事件先触发</p>
<p>如果你的js文件涉及DOM操作，可以直接在<code>DOMContentLoaded</code>里面添加回调函数，或者说基本上我们的js文件都可以写在里面进行调用. </p>
<p>其实，这和我们将js文件放在body底部，在js上面加async,defer,以及hard Callback异步加载js文件的效果是一样的。</p>
<h1 id="jquery-ready事件浅析"><a href="#jquery-ready事件浅析" class="headerlink" title="jquery ready事件浅析"></a>jquery ready事件浅析</h1><p>jquery主要做的工作就是兼容IE6,7,8实现<code>DOMContentLoaded</code>的效果<br>目前流行的做法有两种， 一种是使用<code>readystatechange</code>实现，另外一种使用IE自带的<code>doScroll</code>方法实现.</p>
<h2 id="readyStateChange"><a href="#readyStateChange" class="headerlink" title="readyStateChange"></a>readyStateChange</h2><p>这其实是IE6，7，8的特有属性，用它来标识某个元素的加载状态。 但是现在w3c规定，只有xhr才有这个事件。 所以，这里，我们一般只能在IE中使用readyStateChange否则，其他浏览器是没有效果的。</p>
<p>这样，我们模拟jquery的ready事件时就可以使用:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.readyState == <span class="string">"interactive"</span> || <span class="built_in">document</span>.readyState == <span class="string">"complete"</span>) &#123;</span><br><span class="line">        <span class="comment">//添加回调...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>理想很丰满，现实很骨感。 事实上, 当<code>readyState</code>为<code>interactive</code>时， Dom的结构并未完全稳定，如果还有其他脚本影响DOM时, 这时候可能会造成bug。</p>
<p> 另外为<code>complete</code>时， 这时候图片等相关资源已经加载完成。 这个时候模拟触发<code>DOMContentLoaded</code>事件，其实和<code>onload</code>事件触发时间并没有太久的时间距离。 </p>
<p> 这种方式兼容低版本IE还是不太可靠的。</p>
<h2 id="doScroll"><a href="#doScroll" class="headerlink" title="doScroll"></a>doScroll</h2><p>这是IE低版本特有的，不过IE11已经弃用了。 使用<code>scrollLeft</code>和<code>scrollTop</code>代替.<code>doScroll</code>的主要作用是检测DOM结构是否稳定， </p>
<p>通常我们会使用<code>轮询</code>来检测<code>doScroll</code>是否可用，当可用的时候一定是DOM结构稳定，图片资源还未加载的时候。</p>
<p>我们来看一下jquery中实现doScroll的兼容:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//低版本的IE浏览器，这里添加监听作为向下兼容，如果doScroll执行出现bug，也能保证ready函数的执行</span></span><br><span class="line">    <span class="built_in">document</span>.attachEvent( <span class="string">"onreadystatechange"</span>, DOMContentLoaded );</span><br><span class="line">     <span class="built_in">window</span>.attachEvent( <span class="string">"onload"</span>, jQuery.ready );</span><br><span class="line"><span class="comment">//在ready里面会对执行做判断，确保只执行一次</span></span><br><span class="line">     <span class="keyword">var</span> top = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 如果是IE且不是iframe就通过不停的检查doScroll来判断dom结构是否ready</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    top = <span class="built_in">window</span>.frameElement == <span class="literal">null</span> &amp;&amp; <span class="built_in">document</span>.documentElement;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> ( top &amp;&amp; top.doScroll ) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">doScrollCheck</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !jQuery.isReady ) &#123;<span class="comment">//ready方法没有执行过</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 检查是否可以向左scroll滑动,当dom结构还没有解析完成时会抛出异常</span></span><br><span class="line">                top.doScroll(<span class="string">"left"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                <span class="comment">//递归调用,直到当dom结构解析完成</span></span><br><span class="line">                <span class="keyword">return</span> setTimeout( doScrollCheck, <span class="number">50</span> );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有发现异常,表示dom结构解析完成,删除之前绑定的onreadystatechange事件</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//执行jQuery的ready方法</span></span><br><span class="line">            jQuery.ready();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//看看jQuery.ready()方法:</span></span><br><span class="line">ready:<span class="function"><span class="keyword">function</span>(<span class="params">wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (wait === <span class="literal">true</span> ? --jQuery.readyWait : jQuery.isReady) &#123;</span><br><span class="line">        <span class="comment">//判断页面是否已完成加载并且是否已经执行ready方法</span></span><br><span class="line">        <span class="comment">//通过isReady状态进行判断, 保证只执行一次</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">document</span>.body) &#123;</span><br><span class="line">        <span class="keyword">return</span> setTimeout(jQuery.ready);</span><br><span class="line">    &#125;</span><br><span class="line">    jQuery.isReady = <span class="literal">true</span>; <span class="comment">//指示ready方法已被执行</span></span><br><span class="line">      <span class="comment">//这也是上面两次绑定事件的原因,会保证只执行一次</span></span><br><span class="line">    <span class="keyword">if</span> (wait !== <span class="literal">true</span> &amp;&amp; --jQuery.readyWait &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下是处理ready的状态</span></span><br><span class="line">    readyList.resolveWith(<span class="built_in">document</span>, [jQuery]);</span><br><span class="line">    <span class="keyword">if</span> (jQuery.fn.trigger) &#123;</span><br><span class="line">    <span class="comment">//解除引用</span></span><br><span class="line">        jQuery(<span class="built_in">document</span>).trigger(<span class="string">"ready"</span>).off(<span class="string">"ready"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/学习/">学习</a>►<a class="article-category-link" href="/categories/学习/专题笔记/">专题笔记</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/面试/">面试</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/study/2017/9/25-react-cnode-guide.html" title="react-cnode实践笔记" itemprop="url">react-cnode实践笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Ruiyu Lin" target="_blank" itemprop="author">Ruiyu Lin</a>
		
  <p class="article-time">
    <time datetime="2017-09-24T16:00:00.000Z" itemprop="datePublished"> Published 2017-09-25</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>参照源码</p>
<p><a href="http://react-china.org/t/webpack-react-react-router-redux-less-flex-css-es6-react-cnode/6332" target="_blank" rel="noopener">http://react-china.org/t/webpack-react-react-router-redux-less-flex-css-es6-react-cnode/6332</a></p>
<p>这里面写得有点乱，看不太明白，所以自己学着边学边做,项目地址</p>
<p><a href="https://github.com/LRY1994/react-cnode-re" target="_blank" rel="noopener">https://github.com/LRY1994/react-cnode-re</a></p>
<h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><p>1.搭建react项目结构，直接用官网的方法 create-react-app react-cnode-re</p>
<p>2.添加less配置<br>使用create-react-app 创建的项目默认不支持less，按照<a href="https://segmentfault.com/a/1190000010162614配置" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010162614配置</a></p>
<h3 id="用到的知识点"><a href="#用到的知识点" class="headerlink" title="用到的知识点"></a>用到的知识点</h3><p>1.react小书，里面讲得很通俗易懂 <a href="http://huziketang.com/books/react/" target="_blank" rel="noopener">http://huziketang.com/books/react/</a></p>
<p>2.布局使用flex.css，移动端flex布局神器，兼容微信，UC，webview等移动端主流浏览器08.10</p>
<p>npm install flex.css –save</p>
<p>flex.css使用方法</p>
<pre><code>dir：主轴方向
        top：从上到下
        right：从右到左
    bottom：从上到下
    left：从左到右（默认）
main：主轴对齐方式
    right：从右到左
    left：从左到右（默认）
    justify：两端对齐
        center：居中对齐
cross：交叉轴对齐方式
    top：从上到下
    bottom：从上到下
    baseline：跟随内容高度对齐
    center：居中对齐
    stretch：高度并排铺满（默认）
box：子元素设置
    mean：子元素平分空间
    first：第一个子元素不要多余空间，其他子元素平分多余空间
    last：最后一个子元素不要多余空间，其他子元素平分多余空间
    justify：两端第一个元素不要多余空间，其他子元素平分多余空间
</code></pre><p>3.整个项目的基础结构就是</p>
<pre><code>&lt;Provider store={store}&gt;
    &lt;Router history={history}&gt;
        &lt;Switch&gt;
            &lt;Route key=’’ path=’’ component=’’/&gt;
            &lt;Route key=’’ path=’’ component=’’/&gt;
            ………………………………..
        &lt;/Switch&gt;
    &lt;/Router&gt;
&lt;/Provider&gt;
</code></pre><p>4.下拉动态加载用到时 get-next-page 插件</p>
<p>她自己自动监听了这些事件，不用自己写触发事件，比如下拉的时候回自动拉取下一页数据</p>
<p>this.monitorEvent = [‘DOMContentLoaded’, ‘load’, ‘click’, ‘touchstart’, ‘touchend’, ‘haschange’, ‘online’, ‘pageshow’, ‘popstate’, ‘resize’, ‘storage’, ‘mousewheel’, ‘scroll’];</p>
<p>只需要写好el,拉取的数据就会放在el </p>
<p>使用方法：</p>
<pre><code>import GetNextPage from ‘get-next-page’
new GetNextPage(el,setting)


setting参数如下

/*元素在可视区位置，符合其中一个条件就会触发加载机制*/

top    //元素在顶部伸出的距离才加载
right  //元素在右边伸出的距离才加载
bottom //元素在底部伸出的距离才加载
left   //元素在左边伸出的距离才加载

    /*
    发送到服务器的相关数据
*/
url  //发送到服务器的地址
data //发送到服务器的数据
pageName  //分页的参数名称，用来加载完成后+1
/*
    回调方法
*/
start  //开始加载时调用方法
load //加载成功时调用方法
error  //开始加载时调用方法
end  //加载完成时调用方法   
</code></pre><h3 id="遇到的问题及得到的知识点"><a href="#遇到的问题及得到的知识点" class="headerlink" title="遇到的问题及得到的知识点"></a>遇到的问题及得到的知识点</h3><p>1.You should not use <route> or withRouter() outside a <router></router></route></p>
<p>源码里面是每个路由导航的Component都包含一个Rooter，我想要整个页面就用一个Footer，但是Footer里面包含了<route>,<route>必须包含 在<rooter>里面，所以不可以这样写</rooter></route></route></p>
<pre><code>render(
&lt;Provider store={store}&gt;
        &lt;div&gt;
        {router}
        &lt;Footer/&gt;
    &lt;/div&gt;

&lt;/Provider&gt;,
document.getElementById(&apos;root&apos;)
)
</code></pre><p>2.React.Children.only expected to receive a single React element child.</p>
<pre><code>&lt;Router&gt;&lt;Provider&gt;里面只能有一个一级子节点,Provider的store是必须的，Router的history是必须的
</code></pre><p>History用这种方法创造</p>
<pre><code>import createBrowserHistory from &apos;history/createBrowserHistory&apos;;
const history = createBrowserHistory();
</code></pre><p>好像还可以这样写。但是不知道有什么区别</p>
<pre><code>var history = process.env.NODE_ENV !== &apos;production&apos; ? browserHistory : hashHistory;
</code></pre><p>3.修改react启动的端口号</p>
<p>打开react项目的 package.json文件</p>
<p>将 scripts中的start键值对</p>
<pre><code>&quot;start&quot;: &quot;node scripts/start.js&quot;,
</code></pre><p>修改为<br>    “start”: “set PORT=3000&amp;&amp;node scripts/start.js”,</p>
<p>4.React并没有一个自己的Component处理网络请求，自己包装HttpService.js</p>
<p>5.render 方法必须要返回一个 JSX 元素。而且必须要用一个外层的 JSX 元素把所有内容包裹起来。返回并列多个 JSX 元素是不合法的</p>
<p>6.{this.props.children}相当于angular的<ui-view></ui-view></p>
<p><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/1.jpg" alt="Aaron Swartz"></p>
<p>参考 <a href="https://segmentfault.com/q/1010000009616045" target="_blank" rel="noopener">https://segmentfault.com/q/1010000009616045</a></p>
<p>react-router4没有indexRoute了。 react-router4版本中路由的本质变成了React组件，也就是自定义标签。所以你可以像使用组件一样是用路由。那么嵌套路由无非就是组件嵌套的写法（自定义标签嵌套而已）</p>
<p>7.</p>
<pre><code>&lt;Route path=&quot;/&quot; component={App} /&gt;
&lt;Route exact path=&quot;/&quot; component={Home} /&gt;
&lt;Route path=&quot;topics&quot; component={Topics} /&gt;
&lt;Route path=&quot;/topics/:id&quot; component={Topic} /&gt;
</code></pre><p>这里用react-router-dom，用{this.props.children}渲染不出组件，放弃这种做法</p>
<p>8.没有传入action 之前，会出现这个错误</p>
<p><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/2.jpg" alt="Aaron Swartz"></p>
<p>9.想要在chrome控制台下查看react,出现这个问题</p>
<p>proxyConsole.js:56 The previous state received by the reducer has unexpected type of “Function”. Expected argument to be an object with the following keys: “User”</p>
<p><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/3.jpg" alt="Aaron Swartz"></p>
<p>原因见以下链接</p>
<p><a href="https://stackoverflow.com/questions/38074154/redux-the-previous-state-received-by-the-reducer-has-unexpected-type-of-functi" target="_blank" rel="noopener">https://stackoverflow.com/questions/38074154/redux-the-previous-state-received-by-the-reducer-has-unexpected-type-of-functi</a></p>
<p>改成</p>
<pre><code>const store = createStore(
    combineReducers(reducer),
    compose(applyMiddleware(thunk),composeWithDevTools())    
);
</code></pre><p>10.在reducer里面返回新的state,就是store</p>
<p>reducer只有在createStore的时候用到，其他地方没有用到，不用管。</p>
<p>Connet的时候就是组件丛store里面取出自己需要的东西，仅仅是自己需要的数据。</p>
<p>只有触发的时候用到dispatch，其他时候没有用到。</p>
<p>刚开始想像一般推荐的那种方法那样弄两个文件夹Component和Container，试了一天，最后发现store是放共享的东西，我为什么什么都要往里面放。还有一个组件写两个文件很繁琐，直接像源码里面在组件最后connect一下就好了</p>
<p>总体流程就是</p>
<pre><code>Reducer
createStore(reducer)
action
connect(props,action)
this.props.（action.type）(arg)

手动调用this.props.（action.type）(arg)--&gt;react-redux自动对应到reducer--&gt;react-redux自动更新props
</code></pre><p>11.前往某个制定的页面</p>
<pre><code>this.context.router.history.push({
                    pathname: &apos;/user/&apos; + res.loginname
                });
</code></pre><p>12.mapDispatchToProps可以返回一个对象，action(‘User’)返回对象,每个元素都是函数</p>
<pre><code>{
    &apos;signinSuccess&apos;:( target)=&gt;{
        _ID: User, 
        target: target, 
        type: &apos;signinSuccess&apos; 
},
&apos;signin&apos;: ( target)=&gt;{
        _ID: User, 
        target: target, 
        type: &apos;signin&apos;
},
‘setState’: ( target)=&gt;{
        _ID: User, 
        target: target, 
        type: ‘setState’
},
}


export default (_ID) =&gt; {
    var action = {};
    var arr = [
        &apos;signinSuccess&apos;, //登录成功
        &apos;signin&apos;, //退出登录
        &apos;setState&apos; //设置状态
    ];

    for (let i = 0; i &lt; arr.length; i++) {
        action[arr[i]] = (target) =&gt; {
            return { 
                _ID: _ID, 
                target: target, 
                type: arr[i] 
            };
        }
    }

    return action;
} 


export default connect((state) =&gt; { return { User: state.User }; }, action(&apos;User&apos;))(SignIn); //连接redux

connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])(组件)
</code></pre><p>[mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function): 如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，而且这个对象会与 Redux store 绑定在一起，其中所定义的方法名将作为属性名，合并到组件的 props 中。</p>
<p>13.在signin里面不connect的时候super(props)输出来的props是这样的，默认的props是<br><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/4.jpg" alt="Aaron Swartz"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">history:</span><br><span class="line">    action:&quot;POP&quot;/&quot;PUSH&quot;</span><br><span class="line">    block:ƒ block()</span><br><span class="line">    createHref:ƒ createHref(location)</span><br><span class="line">    go:ƒ go(n)</span><br><span class="line">    goBack:ƒ goBack()</span><br><span class="line">    goForward:ƒ goForward()</span><br><span class="line">    length:2//浏览器历史列表中的 URL 数量</span><br><span class="line">    listen:ƒ listen(listener)</span><br><span class="line">    location:&#123;</span><br><span class="line">pathname: &quot;/signin&quot;, //同window.location.pathname</span><br><span class="line">search: &quot;&quot;, //同window.location.search</span><br><span class="line">hash: &quot;&quot;, </span><br><span class="line">state: undefined,// 一个捆绑在这个地址上的object对象</span><br><span class="line">key: &quot;wytc8y&quot;&#125;</span><br><span class="line">    push:ƒ push(path, state)</span><br><span class="line">    replace:ƒ replace(path, state)</span><br><span class="line">location:和history.location内容一样</span><br><span class="line">match:</span><br><span class="line">    isExact:true //路由extract设置为true</span><br><span class="line">    params:&#123;&#125;</span><br><span class="line">    path:&quot;/signin&quot;</span><br><span class="line">    url:&quot;/signin&quot;</span><br><span class="line">staticContext:undefined</span><br></pre></td></tr></table></figure></p>
<p>connect之后多了User,和三个action setState,signin,signinSuccess</p>
<p><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/5.jpg" alt="Aaron Swartz"></p>
<p>我把default改成return null,User值会变化<br><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/6.png" alt="Image text"><br><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/7.png" alt="Aaron Swartz"></p>
<p>User为什么在props上？因为connect的时候取名叫做User</p>
<p><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/8.png" alt="Aaron Swartz"></p>
<p>14.在user reducer这里输出看看action有什么<br>刚开始是这样的，应该是combineReducer的时候先占位，但是还没有装入</p>
<p><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/9.png" alt="Aaron Swartz"></p>
<p>登录成功后两处输出是一样的， </p>
<p><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/10.png" alt="Aaron Swartz"></p>
<p>Action</p>
<p><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/11.jpg" alt="Aaron Swartz"></p>
<p>15<br><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/12.png" alt="Aaron Swartz"></p>
<p>验证成功，把reducer函数名称改一下</p>
<p><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/13.png" alt="Aaron Swartz"><br><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/14.png" alt="Aaron Swartz"></p>
<p>16.高阶组件是一个函数（而不是组件）,原项目里面的GetNextPage.jx相当于IndexList的高阶组件，用到了get-next-page插件</p>
<p><a href="https://segmentfault.com/n/1330000011305070" target="_blank" rel="noopener">用于下拉自动加载数据get-next-page插件</a></p>
<p>17.组件必须大写字母开头，不然会当做html的标签</p>
<p>18.<br>this.refs.dataload<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ref=&quot;dataload&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>19.生命周期知识点</p>
<p>Mounting</p>
<p>These methods are called when an instance of a component is being created and inserted into the DOM:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">•	constructor()</span><br><span class="line">•	componentWillMount()</span><br><span class="line">•	render()</span><br><span class="line">•	componentDidMount()</span><br></pre></td></tr></table></figure></p>
<p>Updating</p>
<p>These methods are called when a component is being re-rendered:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">•	componentWillReceiveProps()</span><br><span class="line">•	shouldComponentUpdate()</span><br><span class="line">•	componentWillUpdate()</span><br><span class="line">•	render()</span><br><span class="line">•	componentDidUpdate()</span><br></pre></td></tr></table></figure></p>
<p>Unmounting</p>
<p>This method is called when a component is being removed from the DOM:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">•	componentWillUnmount()</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/15.png" alt="Aaron Swartz"></p>
<p>打开localhost的时候，/home初始化，因为调用了两次setState,所以调用了两次componentWillReceiveProps,<br>Prop改变会自动触发componentWillReceiveProps, shouldComponentUpdate ,componentWillUpdate ,render,componentDidUpdate,每一次改变prop就会触发这些<br>State改变需要使用setState方法设置，然后会自动调用shouldComponentUpdate,componentWillUpdate,render, componentDidUpdate()。跟Prop改变不同的是，state改变可能不会立即触发，他会和其他合并之后再触发</p>
<p><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/16.png" alt="Aaron Swartz"></p>
<p>原因</p>
<p><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/17.png" alt="Aaron Swartz"></p>
<p><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/18.png" alt="Aaron Swartz"></p>
<p>下拉的时候同样是两次</p>
<p><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/19.png" alt="Aaron Swartz"></p>
<p>接着切换为tab=good</p>
<p><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/20.png" alt="Aaron Swartz"></p>
<p>这里多了一次是URL改变也触发了一次setState</p>
<p><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/21.png" alt="Aaron Swartz"></p>
<p>tab=good的时候下拉</p>
<p><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/22.png" alt="Aaron Swartz"></p>
<p>点击“发表”</p>
<p><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/23.png" alt="Aaron Swartz"></p>
<p>再回来“首页”，</p>
<p><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/24.png" alt="Aaron Swartz"></p>
<p>但是什么原理导致HomeContainer的prop改变？？ 每次调用action就会引起props改变，这是redux内部自动实现的</p>
<p><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/25.png" alt="Aaron Swartz"></p>
<p>17.super()和super(props)的区别在于能否在子类prototype的constructor中调用this,props</p>
<p>18.首页用一个数组存储每个tab之前浏览的情况,但是这里有个情况，/home和/home?tab=all区别存储了</p>
<p><img src="https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/26.png" alt="Aaron Swartz"></p>
<p>19.获取参数方式</p>
<p><a href="http://localhost:4000/home?tab=good" target="_blank" rel="noopener">http://localhost:4000/home?tab=good</a></p>
<pre><code>queryString.parse(props.location.search).tab
</code></pre><p><a href="http://localhost:4000/topic/5555" target="_blank" rel="noopener">http://localhost:4000/topic/5555</a> </p>
<pre><code>&lt;Route path=&quot;users&quot; component={Users}&gt;
    &lt;Route path=&quot;/user/:userId&quot; component={User}/&gt;
&lt;/Route&gt;
&lt;Link to={/user/${user.id}}&gt;{user.name}&lt;/Link&gt;
    props.match.params. userId
</code></pre><p>20.props.dangerouslySetInnerHTML must be in the form {__html: …}</p>
<pre><code>dangerouslySetInnerHTML=\{\{__html:content\}\}
</code></pre><p>21.前往某个页面</p>
<pre><code>this.context.router.history.push({
                pathname: &apos;/topic/&apos; + res.topic_id
            });
</code></pre><p>22.任何想访问context里面的属性的组件都必须显式的指定一个contextTypes 的属性。如果没有指定改属性，那么组件通过 this.context 访问属性将会出错</p>
<p>23.process.cwd()当前工作目录（Current Work Directory）</p>
<p>24.this.context.router.push(‘/‘) ，注：这个写法会把跳转载入浏览器历史，若不想留下历史记录则可以 this.context.router.replace(‘/‘) </p>
<p>最后我把源码里面的redux形式改成这样connect(mapStateToProps,mapDispatchToProps)(SignIn)这种形式，在网上看好像大家也比较接受这种形式</p>
<pre><code>const mapStateToProps = (state) =&gt; {
    return {
    User: state.User
    }
}

const mapDispatchToProps = (dispatch) =&gt; {
    return {
        signinSuccess: (user) =&gt; {
            dispatch(signinSuccess(user))
        }
    }
}

export default connect(mapStateToProps,mapDispatchToProps)(SignIn); //连接redux
</code></pre><h3 id="待解决（已解决）"><a href="#待解决（已解决）" class="headerlink" title="待解决（已解决）"></a>待解决（已解决）</h3><p>npm run build的时候出错</p>
<blockquote>
<p>Failed to minify the code from this file: ./~/get-next-page/dist/get-next-page.js:59 Read more here:      <a href="http://bit.ly/2tRViJ9" target="_blank" rel="noopener">http://bit.ly/2tRViJ9</a> </p>
</blockquote>
<p> 原项目是自己写的webpack配置文件。我全是create-react-app自动生成的，不想改,网上查到这段话</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm run build fails to minify</span><br><span class="line"></span><br><span class="line">You may occasionally find a package you depend on needs compiled or ships code for a non-browser environment.</span><br><span class="line">This is considered poor practice in the ecosystem and does not have an escape hatch in Create React App.</span><br><span class="line"></span><br><span class="line">To resolve this:</span><br><span class="line"></span><br><span class="line">Open an issue on the dependency&apos;s issue tracker and ask that the package be published pre-compiled (retaining ES6 Modules).</span><br><span class="line">Fork the package and publish a corrected version yourself.</span><br><span class="line">If the dependency is small enough, copy it to your src/ folder and treat it as application code.</span><br><span class="line">Something Missing?</span><br></pre></td></tr></table></figure>
<p>我这里用第三种方法，把get-netx-page.js放到/src/lib里面，相应的地方再改改，就可以了，npm run build之后就会生成build文件夹</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>参考 <a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#deployment" target="_blank" rel="noopener">部署方法</a></p>
<pre><code>&gt;npm install -g serve
&gt;serve -s build

打开localhost:5000 ,成功
</code></pre><h3 id="疑问："><a href="#疑问：" class="headerlink" title="疑问："></a>疑问：</h3><p>通过createHistory()方法生成的history和react-router中的history有什么区别？？？</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/学习/">学习</a>►<a class="article-category-link" href="/categories/学习/专题笔记/">专题笔记</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/react/">react</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/study/2017/7/17-angualr.html" title="读《AngularJS深度剖析与最佳实践》" itemprop="url">读《AngularJS深度剖析与最佳实践》</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Ruiyu Lin" target="_blank" itemprop="author">Ruiyu Lin</a>
		
  <p class="article-time">
    <time datetime="2017-07-16T16:00:00.000Z" itemprop="datePublished"> Published 2017-07-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><img src="/images/book/angualr-deep-analysics.png" alt="cover"></p>
<h3 id="组件型指令"><a href="#组件型指令" class="headerlink" title="组件型指令"></a>组件型指令</h3><p>对于组件型指令来说，标准的用法是E，但是为了兼容IE8，通<br>常也支持一个A，因为IE8 的自定义元素需要先用document.createElement 注册，用A 可<br>以省去注册的麻烦。对于组件型指令，更重要的是内容信息的展示，所以我们一般不涉及指令的link 函数，而应该尽量地将业务逻辑放置在Controller 中。</p>
<h3 id="指令scope"><a href="#指令scope" class="headerlink" title="指令scope"></a>指令scope</h3><p>由于多个装饰器很可能被用于同一个指令，包括独立作用域指令，所以装饰<br>器型指令通常不使用新作用域或独立作用域。如果要访问绑定属性，该怎么做呢？仍然看<br>前面的例子<br><code>&lt;user-details name=&quot;test&quot; details=&quot;details&quot; on-update=&quot;updateIt(times)&quot;&gt;&lt;/userdetails&gt;</code>，<br>假如不使用独立作用域，我们该如何获取这些属性的值呢？<br>●对于 @ 型的绑定，我们可以直接通过 attrs 取到它：attrs.name 等价于 name: ‘@’。<br>● 对于 = 型的绑定，我们可以通过 scope.$eval 取到它：scope.$eval(attrs.details) 等价</p>
 <img src="/study/2017/7/17-angualr/2.png" title="section">
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>过滤器还可以接收第二个参数，乃至第N个参数，如：<code>return function(input, arg1, arg2, arg3){...};</code>,而使用者则通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;1|myFilter:2:3:4&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>的形式调用它。这种情况下，arg1 的值为2，arg2的值为3，arg3 的值为4。</p>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>除了Constant 外，所有这些类型的服务，背后都是通过Provider 实现的，我们可以把它们看做让Provider 更容易写的语法糖。</p>
<p>Angular 提供了这么多种形式的服务，那么我们在工程实践中该如何选择？我们可以遵<br>循下列决策流程：</p>
<p>● 需要全局的可配置参数？用 Provider。</p>
<p>● 是纯数据，没有行为？用 Value。</p>
<p>● 只 new 一次，不用参数？用 Service。</p>
<p>● 拿到类，我自己 new 出实例？用 Factory。</p>
<p>● 拿到函数，我自己调用？用 Factory。</p>
<p>但是，还有另一种更加敏捷的方式：<br>●是纯数据时，先用 Value ；当发现需要添加行为时，改写为 Service ；或当发现需<br>要通过计算给出结果时，改写为Factory ；当发现需要进行全局配置时，改写为Provider。</p>
<p>● 最酷的是，这个过程对于使用者是透明的—它不需要因为实现代码的改动而更改<br>原有代码。如上面Value 和Factory 的使用代码，仅仅从使用代码中我们区分不出<br>它是Value 还是Factory。</p>
<p>接下来，我们来看Constant。与其他Service 不同，Constant 不是Provider 函数的语法<br>糖。更重要的差别是，它的初始化时机非常早，可以在angular.module(‘com.ngnice.app’).<br>config 函数中使用，而其他的服务是不能被注入到config 函数中的。这也意味着，如果你<br>需要在config 中使用一个全局配置项，那么它就只能声明为常量，而不能声明为变量。<br>在官方的开发指南中，给出了一个完整的对比表，见表2-1。</p>
<img src="/study/2017/7/17-angualr/service-kind.png" title="service-kind">
<p>由于 Factory 可以根据程序逻辑返回不同的数据类型，所以我们无法推断其结果是什么类型，也就是对类型不够友好。Provider 由于其灵活性比Factory 更高，因此在类型友好性上和<br>Factory 是一样的。</p>
<p>● 在 config 阶段可用：只有 Constant 和 Provider 类型在 config 阶段可用，其他都是<br>Provider 实例化之后的结果，所以只有config 阶段完成后才可用。由于Service 是new 出来的，所以其结果必然是类实例，<br>也就无法直接返回一个可供调用的函数或数字等原生对象。<br>如果你确实需要对一个没有提供Provider 的第三方服务进行配置，该怎么办呢？<br>Angular 提供了另一种机制：decorator。</p>
<h3 id="angualr-mvc"><a href="#angualr-mvc" class="headerlink" title="angualr mvc"></a>angualr mvc</h3>  <img src="/study/2017/7/17-angualr/mvc.png" title="mvc">
<h3 id="angular启动过程"><a href="#angular启动过程" class="headerlink" title="angular启动过程"></a>angular启动过程</h3>  <img src="/study/2017/7/17-angualr/start-process.png" title="start-process">
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3>  <img src="/study/2017/7/17-angualr/1.png" title="section">
<h3 id="浏览事件循环"><a href="#浏览事件循环" class="headerlink" title="浏览事件循环"></a>浏览事件循环</h3>  <img src="/study/2017/7/17-angualr/event-loop.png" title="loop">
<h3 id="指令生命周期"><a href="#指令生命周期" class="headerlink" title="指令生命周期"></a>指令生命周期</h3>  <img src="/study/2017/7/17-angualr/directive-life-cycle.png" title="cycle">
<h3 id="one-time绑定"><a href="#one-time绑定" class="headerlink" title="one-time绑定"></a>one-time绑定</h3>  <img src="/study/2017/7/17-angualr/3.png" title="section">
  <img src="/study/2017/7/17-angualr/4.png" title="section">
<h3 id="滚屏加载"><a href="#滚屏加载" class="headerlink" title="滚屏加载"></a>滚屏加载</h3>  <img src="/study/2017/7/17-angualr/5.png" title="section">
<p><a href="http://sroze.github.io/ngInfiniteScroll/index.html" target="_blank" rel="noopener">http://sroze.github.io/ngInfiniteScroll/index.html</a></p>
<p>get可以用来取本地文件，其他不可以</p>
<h3 id="js-object-layout"><a href="#js-object-layout" class="headerlink" title="js object layout"></a>js object layout</h3> 
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3>  <img src="/study/2017/7/17-angualr/7.png" title="section">
<h3 id="anchorScroll服务"><a href="#anchorScroll服务" class="headerlink" title="$anchorScroll服务"></a>$anchorScroll服务</h3>  <img src="/study/2017/7/17-angualr/8.png" title="section">
<h3 id="ngRepeat验证失败-，简单的验证显示"><a href="#ngRepeat验证失败-，简单的验证显示" class="headerlink" title="ngRepeat验证失败 ，简单的验证显示"></a>ngRepeat验证失败 ，简单的验证显示</h3>  <img src="/study/2017/7/17-angualr/9.png" title="section">
<h3 id="复杂的验证显示"><a href="#复杂的验证显示" class="headerlink" title="复杂的验证显示"></a>复杂的验证显示</h3>  <img src="/study/2017/7/17-angualr/10.png" title="section">
<h3 id="ngRepeat报重复内容错误"><a href="#ngRepeat报重复内容错误" class="headerlink" title="ngRepeat报重复内容错误"></a>ngRepeat报重复内容错误</h3>  <img src="/study/2017/7/17-angualr/11.png" title="section">
  <img src="/study/2017/7/17-angualr/12.png" title="section">
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol>
<li><p>代码里很多和界面无交互的函数和变量都挂在$scope上面</p>
<p>$scope是数据展示和各种事件的载体。与展示、交互行为无关的数据和方法最好不要挂载到$scope上，保持$scope的纯粹。<br>参考链接<br><a href="https://github.com/atian25/blog/issues/5" target="_blank" rel="noopener">保持$scope的纯粹</a></p>
</li>
<li><p>避免深度watch， 即第三个参数为true.<br>参考《mastering web application development with angularjs》 P313</p>
<img src="/study/2017/7/17-angualr/avoid-deep-watch.png" title="avoid-deep-watch">
</li>
</ol>
<ol>
<li><p>及时移除不必要的$watch</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> watchFn = $scope.$watch(<span class="string">'cycle'</span>, changeCycle);</span><br><span class="line"></span><br><span class="line">watchFn();<span class="comment">//移除watch</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>减少watch的变量长度，例如对双向绑定的变量用标签例如<span>包起来</span></p>
<img src="/study/2017/7/17-angualr/shorten-watch.png" title="shorten-watch">
</li>
<li><p>ng-repeat使用 track by</p>
<p>刷新数据时，我们常这么做：$scope.tasks = data || [];，这会导致angular移除掉所有的DOM，重新创建和渲染。</p>
<p>若优化为ng-repeat=”task in tasks track by task.id后，angular就能复用task对应的原DOM进行更新，减少不必要渲染。</p>
</li>
<li><p>列表对象的数据转换，在放入scope之前处理</p>
<p>如$scope.dataList = convert(dataFromServer)</p>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/学习/">学习</a>►<a class="article-category-link" href="/categories/学习/读书笔记/">读书笔记</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/AngularJS1/">AngularJS1</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/study/2017/7/1-start-front-end.html" title="前端启航" itemprop="url">前端启航</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Ruiyu Lin" target="_blank" itemprop="author">Ruiyu Lin</a>
		
  <p class="article-time">
    <time datetime="2017-06-30T16:00:00.000Z" itemprop="datePublished"> Published 2017-07-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>以前开始学前端就是看了这份同学转给我的文档，还是有点指导性质的</p>
<ol>
<li>{ 网站前端 }<br>如果你有耐心坚持个一年以上的话, 我会推荐HTML, css ,js, apache ,php, mysql</li>
</ol>
<p>后三者是需要装软件的, 推荐wamp, 绝佳的一站式环境配置, WampServer, the web development platform on Windows 直接包括了apache, php, mysql三个软件, 省的自己一个一个装.<br>有不少人在评论里问mac os下对应的软件, 这里补充一下: XAMPP Installers and Downloads for Apache Friends</p>
<ol>
<li>首先学习HTML, css, 这两个东西是一套的, 非常容易理解, 把w3school上面的教程过一遍就会了, 记住要一个个过, 千万不要偷懒, 一旦开始偷懒, 你会越来越偷懒, 最后什么都没学成. HTML 教程 , CSS 教程</li>
<li>下一步是学js, js相比前两个会难的多, 因为js才是一门正式的编程语言, 同样, w3school的教程全过一遍, JavaScript 教程 , 教程过完了就可以买书看了, 强烈推荐一本超好入门书: 《JavaScript DOM编程艺术（第2版）》(Jeremy Keith，Jeffrey Sambells)【摘要 书评 试读】 , 认真学, 多看, 看完之后学jquery, 这个时候你基本能够了解语言库了, jquery 也直接过一遍w3school的教程,jQuery 教程 . jquery会了, 基本上你网页开发前端就已经入门了, 如果你学的扎实, 反复的看, 其实你就可以胜任前端开发的工作了, 不过浏览器兼容性还是解决不了的, 不过你目标不是前端工程师, 浏览器的兼容性不了解也无所谓.</li>
<li>在第二步你学习js的时候, 你可能就接触一些后端的东西, 没错, 就是ajax. 这个是需要后端返回数据的. 这个时候你要开始学习php了, 入门php相比于js会更麻烦一些, 因为运行php需要有很多细节要处理, 所以一本好的入门书籍是非常重要的, 这个w3school上面的php帮不了什么忙了, 推荐一本书: 《php和mysql web开发（原书第4版）》([澳]威利，[澳]汤姆森)【摘要 书评 试读】 , 当然, 这过程中你会遇到各种各样的问题, 但是如果你学到了这一步, 非常欢迎你私信我来学习, 我绝对帮助, 现在肯学习的孩子太少了, 而且题主才上高中, 太难能可贵了.</li>
<li>一些注意点, 学习HTML, css, js的时候, 只要有浏览器就够了, 不需要装wamp, 编辑器推荐sublime, 多用google, 多敲代码, 尤其是多敲代码非常重要, 不敲代码你什么都学不会. 其他的想起来再补充吧.</li>
</ol>
<p>对于那些说加入xxx阵营的, 不要理他们, 直接在win上面学, php和apache对win的兼容性非常好, 完全可以从入门学到精通都无需碰linux. 当然, 如果你网站最终上线的话, 还是需要接触linux服务器进行部署. 这个到需要部署的时候再说, 提前接触linux就是浪费时间.2014-02-16</p>
<ol>
<li>网站开发开发大致分为前端和后端，前台主要负责实现视觉和交互效果，以及与服务器通信，完成业务逻辑。可以按如下思路学习系统学习：<br>基础知识：</li>
<li>html + css 这部分建议在 w3school 在线教程 上学习，边学边练，每章后还有小测试。 之后可以模仿一些网站做些页面。在实践中积累了一些经验后，可以系统的读一两本书，推荐《head first html 与 css 中文版》，这本书讲的太细了，我没能拿出耐心细读。你可以根据情况斟酌。 </li>
<li>javascript 要学的内容实在很多，如果没有其他编程语言的基础的话，学起来可能要费些力，还是建议先在 w3school上学习。之后建议马上看《javascript语言精粹》，js是一门很混乱的语言，这本书能够帮助你区分哪些是语言的精华，哪些是糟粕，对于语言精华，应该深入学习。糟粕部分能看懂别人写的代码就行，自己就不用尝试了。<br>进阶：<br>有了以上基础，就可以进行一般的静态网页设计，不过对于复杂的页面还学进一步学习。</li>
<li>css。必看《精通css》，看完这本书你应该对：盒子模型，流动，block，inline，层叠，样式优先级，等概念非常了解了。作为练习可以看下《css艺门之匠》这本书，它对标题，背景，圆角，导航条，table，表单等主题都有详细的介绍。</li>
<li>javascript。上面提到内容还不足以让你胜任js编程。在有了基础之后，进一步学习内容包括：</li>
</ol>
<p>a) 框架。推荐jQuery，简单易用，我的第一web项目就是在w3school简单学习后，直接上手jQuery完成的，真的很简单，很好用。jQuery适用环境有限，对于那些对性能要求很高的页面无法胜任。推荐了解一下 YUI 或百度的 tangram ，都很好用，学习方法也很简单，照着产品文档做几个页面就行了，不用面面俱到，以后遇到问题查文档就行了。框架可以帮你屏蔽浏览器的差异性，让你能更专注与web开发学习的精髓部分。补充： 可以使用 codecademy 学习 javascript，jQuery，用户体验真的很好（感谢 TonyOuyang ）。 </p>
<p>b) javascript 语言范式 。这个名字可能并不恰当，只是我找不到可以描述“面向对象”，“函数式”这个两个概念的概念。javascript不完全是一个面向对象的语言，它的很多设计理念都有函数编程语言的影子，甚至说如果你不用面向对象，完全可以把它理解成一门函数式编程语言。javascript的很多语言特性，都是因为他具有函数是语言的特点才存在的。这部分推荐先学习面向对象的基本理论，对封装，继承，多态等概念要理解，维基百科，百度百科会是你的帮手，另外推荐《object oriented javascript》，应该有中文版。对与函数式编程我了解的也不系统，不好多说，可以自己百度一下。</p>
<p>c) javascript 语言内部机制。必须弄清如下概念：js中变量的作用域，变量传递方式，函数的定义环境与执行环境，闭包，函数的四种调用方式（一般函数，对象的方法，apply，call），以及四种调用方式下，‘this’指向的是谁。这部分内容你会在《javascript语言精粹》中详细了解。另外，你必须理解json。</p>
<p>d) dom编程，这个web前端工程师的核心技能之一。必读《dom编程艺术》，另外《高性能javascript》这本书中关于dom编程的部分讲的也很好。</p>
<p>e) ajax编程，这是另一核心技术。ajax建议在网上查些资料，了解这个概念的来龙去脉，百度百科，维基百科上的内容就足够了。真正编程是很容易的，如今几乎所有框架都对ajax有良好的封装，编程并不复杂。</p>
<p>f) 了解浏览器差异性。这部分包括css和js两部分，浏览器差异内容很多，建议在实践中多多积累。另外对于浏览器的渲染模式，DOCTYPE等内容应该系统学习。<br>再进一阶：<br>有了以上知识，对于大多数小型网站，你应该已经可以写出能够工作的代码了。但写出可以运行的代码，只是编程的最初级阶段。更高要求大概还有三方面：1易维护，2可测试，3高性能，如果页面流量有要求，那第四个就是，4低流量。</p>
<ol>
<li>易维护。对于页面你该理解‘样式’，‘数据’，‘行为’三者分离，对应的当然就是css,html,js。对于js代码，你最好了解设计模式，重构，MVC等内容。</li>
<li>可测性。js代码可测性的主题，我正在研究，欢迎感兴趣的同学联系我，共同学习</li>
<li>高性能。必读《高性能javascript》</li>
<li>低流量。技巧性太强，非一朝一夕之功，不多说<br>补充：<br>对于前段开发，核心部分基本就这些了，可以根据自己的兴趣爱好选择性学习以下内容。</li>
<li>美工。 大公司都有专业的美工人员，不过如果爱好也可以了解</li>
<li><p>交互设计。大公司依然有专业人士搞这些，不过如果爱好也可了解。推荐《简约至上》。</p>
</li>
<li><p>后端。应该说前段工程师必须至少了解一门后端语言，不过如果爱好也可深入学习，入手难度比较低的应该是php了。这部分由可分为基于页面，基于框架两种。大型项目都是基于框架开发的，建议至少了解一个MVC框架，php的zend，Home : The Official Microsoft ASP.NET Site 的 Home : The Official Microsoft ASP.NET Site mvc等等太多了，好还框架的设计思想都大同小异。</p>
</li>
<li>flash。我并没有吧flash作为前端工程的核心技能之一，因为我不会，不过ActionScript应该和js大同小异，可以根据工作需要学习。不过我的原则是能不用就尽量不用，其实很多效果通过js，css都可以实现，完全不需要flash。而且随着html5的发展flash早晚会淘汰。</li>
<li>html5和css3 。html5的标准到现在还没有正式发布，不过目前几乎所有新的浏览器都已经开始支持，手机上就更是如此，建议学习，很好，很强大。</li>
</ol>
<p>前端开发需要学习的内容，很多很杂。至于视觉设计，交互设计，产品设计，这些内容，如果感兴趣，可以去了解。技术学习，面要铺开，但深度更重要。</p>
<p>前端开发需要学习的内容，很多很杂，我在最开始学习的前两个月也是一片迷茫。一路走来，发现也走了些弯路。美工，交互设计，flash，js，html+css，后端，随便哪种技能，如果学的特别牛，都可以保证你拥有一个职业。想通吃，没个几年怕是不成。关键是选准自己的爱好，深入学习一项，面要铺开，但深度更重要。以上我这一年学习经验的总结，希望对你有帮助。</p>
<ol>
<li>Nicholas C. Zakas谈怎样才能成为优秀的前端工程师：</li>
</ol>
<p>昨天，我负责了Yahoo!公司组织的一次面试活动，感触颇深的是其中的应聘者提问环节。我得说自己对应聘者们提出的大多数问题都相当失望。我希望听到一些对在Yahoo！工作充满激情的问题。在昨天的应聘者中，只有一个人的问题是我认为最好的，那个人问我：“你觉得怎么才能成为优秀的前端工程师？”我觉得很有必要把这个问题从面试房间里拿出来讨论一下。</p>
<p>首先，前端工程师必须得掌握HTML、CSS和JavaScript。只懂其中一个或两个还不行，你必须对这三门语言都很熟悉。也不是说必须对这三门语言都非常精通，但你至少要能够运用它们完成大多数任务，而无需频繁地寻求别人的帮助。</p>
<p>优秀的前端工程师应该具备快速学习能力。推动Web发展的技术并不是静止不动的，没错吧？我甚至可以说这些技术几乎每天都在变化，如果没有快速学习能力，你就跟不上Web发展的步伐。你必须不断提升自己，不断学习新技术、新模式；仅仅依靠今天的知识无法适应未来。Web的明天与今天必将有天壤之别，而你的工作就是要搞清楚如何通过自己的Web应用程序来体现这种翻天覆地的变化。</p>
<p>计算机科学这个大门类下面的许多分支在人们眼中实际上都不外乎科学。但是，我们所说的前端不是什么科学，而是艺术。艺术家不仅要掌握谋生的技术，还要懂得如何运用。对同一个问题的解决方案在这种情况适用，在另一种情况下可能就不适用。对Web应用程序的前端而言，解决同一问题的方案经常会有很多。没有哪个方案是错的，但其中确实有一些是更合适的。优秀的前端工程师应该知道在什么情况下使用哪种方案更合适，而在什么情况下应该重新选择。</p>
<p>优秀的前端工程师需要具备良好的沟通能力，因为你的工作与很多人的工作息息相关。在任何情况下，前端工程师至少都要满足下列四类客户的需求。</p>
<ol>
<li>产品经理——这些是负责策划应用程序的一群人。他们能够想象出怎样通过应用程序来满足用户需求，以及怎样通过他们设计的模式赚到钱（但愿如此）。一般来说，这些人追求的是丰富的功能。</li>
<li>UI设计师——这些人负责应用程序的视觉设计和交互模拟。他们关心的是用户对什么敏感、交互的一贯性以及整体的好用性。他们热衷于流畅靓丽但并不容易实现的用户界面。</li>
<li>项目经理——这些人负责实际地运行和维护应用程序。项目管理的主要关注点，无外乎正常运行时间（uptime）——应用程序始终正常可用的时间、性能和截止日期。项目经理追求的目标往往是尽量保持事情的简单化，以及不在升级更新时引入新问题。</li>
<li>最终用户——当然是应用程序的主要消费者。尽管我们不会经常与最终用户打交道，但他们的反馈意见至关重要；没人想用的应用程序毫无价值。最终用户要求最多的就是对个人有用的功能，以及竞争性产品所具备的功能。</li>
</ol>
<p>那么，前端工程师应该最关注哪些人的意见呢？答案是所有这四类人。优秀的前端工程师必须知道如何平衡这四类人的需求和预期，然后在此基础上拿出最佳解决方案。由于前端工程师处于与这四类人沟通的交汇点上，因此其沟通能力的重要性不言而喻。如果一个非常酷的新功能因为会影响前端性能，必须删繁就简，你怎么跟产品经理解释？再比如，假设某个设计如果不改回原方案可能会给应用程序造成负面影响，你怎么才能说服UI设计师？作为前端工程师，你必须了解每一类人的想法从何而来，必须能拿出所有各方都能接受的解决方案。从某种意义上说，优秀的前端工程师就像是一位大使，需要时刻抱着外交官的心态来应对每一天的工作。</p>
<p>我告诫新来的前端工程师最多的一句话，就是不要在没有作出评估之前就随便接受某项任务。你必须始终记住，一定先搞清楚别人到底想让你干什么，不能简单地接受“这个功能有问题”之类的大概其的说法。而且，你还要确切地知道这个功能或设计的真正意图何在。“加一个按钮”之类的任务并不总意味着你最后会加一个按钮。还可能意味着你会找产品经理，问一问这个按钮有什么用处，然后再找UI设计师一块探讨按钮是不是最佳的交互手段。要成为优秀的前端工程师，这种沟通至关重要。</p>
<p>无论从哪个方面讲，我都觉得前端工程师是计算机科学职业领域中最复杂的一个工种。绝大多数传统的编程思想已经不适用了，为了在多种平台中使用，多种技术都借鉴了大量软科学的知识和理念。成为优秀前端工程师所要具备的专业技术，涉及到广阔而复杂的领域，这些领域又会因为你最终必须服务的各方的介入而变得更加复杂。专业技术可能会引领你进入成为前端工程师的大门，但只有运用该技术创造的应用程序以及你跟他人并肩协同的能力，才会真正让你变得优秀。</p>
<p>网页开发涉及的技术有很多方面，如果想深入学习的话，就必须有所取舍，扎实的基本功才是硬道理，正所谓术业有专攻，并不是所有人都是万能的。<br>就像我，从事php等相关开发已经8年了，但是就你所列出来的那些项技能来说我只能说我精通PHP、SQL等，而js之类的并不是我所擅长的，就是如此。<br>闲话少说，来给你梳理一下吧<br>基本上网站制作和开发分为UI、UE、CODE、DB四个部分，这也就是我说的你要选择的学习方向： </p>
<p>UI指的是网页设计，也就是利用各种素材制作网页的效果图，学习这个需要掌握的就是photoshop、flash、firework之类的工具，当然还要有比较好的审美。 </p>
<p>UE指的是网页前端及用户体验部分的开发，这一阶段需要掌握的有html和javascript以及css。html是所有网页开发的基础要做到滚瓜烂熟，css的话以我的经验是知道常用的即可，剩下的就是具体问题具体分析了。js则比较麻烦，其实现在大家做网站一般都用jquery这个封装好的js库来做，但是我还是建议新手从js的基本语法开始学起，这样遇到了棘手的麻烦才有章可循，而不是一味的google下jquery的plugin之类的 </p>
<p>CODE部分也就是编程部分了，既然你已经学了php了，那就继续深入这门语言好了。我做技术总监也有一阵子了，也面试过很多所谓的phper，我承认他们可能会照猫画虎的写些程序，可真的有些人连include和require的区别是什么都说不出来，就更别提什么值引用之类的了。所以我还是强调基本功，基本功是最重要的，否则你永远就是一个堆代码的蓝领工人，永远写不出高级的程序，永远看不懂国外高手写的牛逼程序。学完基本功后接下来的建议就是找一个开源的PHP框架，读懂它的代码。我刚学php的时候还没有什么很好的框架，我是用一个星期的时间把smarty的源代码读了一遍（后来对其作了优化，速度提升30%）。现在的话这种开源框架多如牛毛，随便找个来看就可以，喜欢中文的话可以看thinkphp，喜欢速度的话可以看doophp，老派一点的话可以看cakephp等等等等。等你把某个具体的框架通读一遍下来之后，你就可以出师了，基本可以秒杀市面上80%的所谓PHPer。 </p>
<p>DB就不多说了，就是数据库层面的，掌握标准的SQL就可以了，做网页的话多了解一些mysql的相关语法和配置什么的也就差不多了。<br>基本也就这些了，看你的学习方向了，祝你早日成功。 </p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/学习/">学习</a>►<a class="article-category-link" href="/categories/学习/专题笔记/">专题笔记</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/前端启航/">前端启航</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/study/Comprehensive/learning-resource.html" title="学习资源收集" itemprop="url">学习资源收集</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Ruiyu Lin" target="_blank" itemprop="author">Ruiyu Lin</a>
		
  <p class="article-time">
    <time datetime="2016-12-31T16:00:00.000Z" itemprop="datePublished"> Published 2017-01-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="Learning-resource"><a href="#Learning-resource" class="headerlink" title="Learning-resource"></a>Learning-resource</h1><h2 id="前端面试题目"><a href="#前端面试题目" class="headerlink" title="前端面试题目"></a>前端面试题目</h2><ul>
<li><a href="https://segmentfault.com/a/1190000013331105?utm_source=index-hottest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013331105?utm_source=index-hottest</a></li>
<li><a href="https://github.com/qiu-deqing/FE-interview" target="_blank" rel="noopener">https://github.com/qiu-deqing/FE-interview</a></li>
<li><a href="https://github.com/fouber/blog" target="_blank" rel="noopener">https://github.com/fouber/blog</a></li>
<li><a href="https://www.imooc.com/article/20319" target="_blank" rel="noopener">https://www.imooc.com/article/20319</a></li>
<li><a href="http://caibaojian.com/40-html5-interview.html" target="_blank" rel="noopener">http://caibaojian.com/40-html5-interview.html</a></li>
</ul>
<h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><ul>
<li>css3 grid layout <a href="https://css-tricks.com/snippets/css/complete-guide-grid/#prop-align-items" target="_blank" rel="noopener">https://css-tricks.com/snippets/css/complete-guide-grid/#prop-align-items</a></li>
</ul>
<h2 id="full-stack"><a href="#full-stack" class="headerlink" title="full stack"></a>full stack</h2><ul>
<li>Growth Engineering: The Definitive Guide。全栈增长工程师指南 <a href="http://growth.phodal.com/" target="_blank" rel="noopener">http://growth.phodal.com/</a></li>
<li>全栈增长工程师实战 <a href="http://growth-in-action.phodal.com/" target="_blank" rel="noopener">http://growth-in-action.phodal.com/</a></li>
</ul>
<h2 id="Jekyll"><a href="#Jekyll" class="headerlink" title="Jekyll"></a>Jekyll</h2><ul>
<li><p>Ovilia’s blog <a href="http://zhangwenli.com/blog" target="_blank" rel="noopener">http://zhangwenli.com/blog</a><br>源码：<a href="https://github.com/Ovilia/blog" target="_blank" rel="noopener">https://github.com/Ovilia/blog</a></p>
</li>
<li><p>axuebin<br><a href="https://github.com/axuebin/blog" target="_blank" rel="noopener">https://github.com/axuebin/blog</a></p>
</li>
<li><p><a href="https://github.com/simongfxu/simongfxu.github.com" target="_blank" rel="noopener">https://github.com/simongfxu/simongfxu.github.com</a></p>
</li>
</ul>
<h2 id="react-react-native-redux"><a href="#react-react-native-redux" class="headerlink" title="react,react-native,redux"></a>react,react-native,redux</h2><ul>
<li><p>react小书里面的例子<br><a href="https://github.com/huzidaha/react-naive-book-examples" target="_blank" rel="noopener">https://github.com/huzidaha/react-naive-book-examples</a></p>
</li>
<li><p>一个 react + redux 的完整项目 和 个人总结<br><a href="https://github.com/bailicangdu/react-pxq" target="_blank" rel="noopener">https://github.com/bailicangdu/react-pxq</a></p>
</li>
<li><p>一个react+redux+webpack+ES6+antd的SPA的后台管理框架demo<br><a href="https://github.com/duxianwei520/react" target="_blank" rel="noopener">https://github.com/duxianwei520/react</a></p>
</li>
<li><p>基于webpack + react + react-router + redux + less + flex.css + ES6 的React版cnode社区<br><a href="https://github.com/lzxb/react-cnode" target="_blank" rel="noopener">https://github.com/lzxb/react-cnode</a></p>
</li>
<li><p>React Native指南汇集了各类react-native学习资源、开源App和组件<br><a href="https://github.com/reactnativecn/react-native-guide" target="_blank" rel="noopener">https://github.com/reactnativecn/react-native-guide</a></p>
</li>
<li><p>Source code of the official F8 app of 2016, powered by React Native and other Facebook open source projects.<br><a href="https://github.com/fbsamples/f8app" target="_blank" rel="noopener">https://github.com/fbsamples/f8app</a></p>
</li>
</ul>
<ul>
<li>Redux 莞式教程。本教程深入浅出，配套入门、进阶源码解读以及文档注释丰满的 Demo 等一条龙服务<br><a href="https://github.com/kenberkeley/redux-simple-tutorial" target="_blank" rel="noopener">https://github.com/kenberkeley/redux-simple-tutorial</a></li>
</ul>
<h2 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h2><ul>
<li><p>express框架应用<br><a href="https://github.com/nswbmw/N-blog" target="_blank" rel="noopener">https://github.com/nswbmw/N-blog</a></p>
</li>
<li><p>express+mongodb+bootstrap blog system<br><a href="https://github.com/mz121star/NJBlog" target="_blank" rel="noopener">https://github.com/mz121star/NJBlog</a></p>
</li>
<li><p>《Node.js 包教不包会》 by alsotang<br><a href="https://github.com/alsotang/node-lessons" target="_blank" rel="noopener">https://github.com/alsotang/node-lessons</a></p>
</li>
</ul>
<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><ul>
<li><p>A curated list of awesome things related to Vue.js<br><a href="https://github.com/vuejs/awesome-vue" target="_blank" rel="noopener">https://github.com/vuejs/awesome-vue</a></p>
</li>
<li><p>记录vue-webapck的学习基础<br><a href="https://github.com/guowenfh/vue-webpack" target="_blank" rel="noopener">https://github.com/guowenfh/vue-webpack</a></p>
</li>
<li><p>Learn Vuex by Building a Notes App<br><a href="https://github.com/coligo-io/notes-app-vuejs-vuex" target="_blank" rel="noopener">https://github.com/coligo-io/notes-app-vuejs-vuex</a></p>
</li>
</ul>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li><p>Packaged version of Ace code editor<br><a href="https://github.com/ajaxorg/ace-builds" target="_blank" rel="noopener">https://github.com/ajaxorg/ace-builds</a></p>
</li>
<li><p>PNotify is a JavaScript notification plugin, developed by SciActive. PNotify can also provide desktop notifications based on the Web Notifications spec. If desktop notifications are not available or not allowed, PNotify will fall back to displaying the notice as a regular, in-browser notice.<br><a href="https://github.com/sciactive/pnotify" target="_blank" rel="noopener">https://github.com/sciactive/pnotify</a></p>
</li>
<li><p>JsGen is a next generation，free, open source web software that you can generate a powerful website, such as blog, forum, etc. It is coded by pure JavaScript, based on Node.js, AngularJS, MongoDB.<br><a href="https://github.com/zensh/jsgen" target="_blank" rel="noopener">https://github.com/zensh/jsgen</a></p>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p>Web Development With Node and Express, first edition.配套代码<br><a href="https://github.com/EthanRBrown/web-development-with-node-and-express" target="_blank" rel="noopener">https://github.com/EthanRBrown/web-development-with-node-and-express</a></p>
</li>
<li><p>《A Practitioner’s Guide to Software Test Design》的中文翻译<br><a href="https://github.com/miaoyinniao/Software-Test-Design-Guide-Cn" target="_blank" rel="noopener">https://github.com/miaoyinniao/Software-Test-Design-Guide-Cn</a></p>
</li>
<li><p>全栈工程师培训材料—阮一峰<br><a href="https://github.com/ruanyf/jstraining" target="_blank" rel="noopener">https://github.com/ruanyf/jstraining</a></p>
</li>
<li><p>分享自己长期关注的前端开发相关的优秀网站、博客、以及活跃开发者<br><a href="https://github.com/LittlewhiteChen/Front-end-collect" target="_blank" rel="noopener">https://github.com/LittlewhiteChen/Front-end-collect</a></p>
</li>
<li><p>前端技能汇总 Frontend Knowledge Structure<br><a href="https://github.com/JacksonTian/fks" target="_blank" rel="noopener">https://github.com/JacksonTian/fks</a></p>
</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/学习/">学习</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/资料收集/">资料收集</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/4/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/学习/专题笔记/" title="专题笔记">专题笔记<sup>23</sup></a></li>
		  
		
		  
			<li><a href="/categories/学习/" title="学习">学习<sup>41</sup></a></li>
		  
		
		  
			<li><a href="/categories/学习/每月总结/" title="每月总结">每月总结<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/生活/" title="生活">生活<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/学习/读书笔记/" title="读书笔记">读书笔记<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/生活/阅读笔记/" title="阅读笔记">阅读笔记<sup>3</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/面试/" title="面试">面试<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/文学/" title="文学">文学<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/vue/" title="vue">vue<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/资料收集/" title="资料收集">资料收集<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/react/" title="react">react<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/reat-native/" title="reat-native">reat-native<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/设计模式/" title="设计模式">设计模式<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/前端优化/" title="前端优化">前端优化<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/DOM/" title="DOM">DOM<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/柯里化/" title="柯里化">柯里化<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/react-native/" title="react-native">react-native<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/栈队列/" title="栈队列">栈队列<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/angular/" title="angular">angular<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/AngularJS1/" title="AngularJS1">AngularJS1<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/H5/" title="H5">H5<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/GreenSock/" title="GreenSock">GreenSock<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/前端启航/" title="前端启航">前端启航<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/ES6/" title="ES6">ES6<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="Ruiyu Lin">Ruiyu Lin</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
