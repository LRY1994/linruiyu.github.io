<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/static/favicon.ico" type="image/x-icon"/>
    <link rel="stylesheet" href="/static/css/all.css" />
    <title>大脸圆玉的博客</title>
</head>
<body>

    <div class="l-nav">
        <div class="nav-img">
    <img src="/static/img/avatar.png"/>
</div>


<ul>
    
        
            <li class="li-active"> <a href="/categories/Experience.html">Experience</a></li>
        
        
            <li > <a href="/categories/Reading.html">Reading</a></li>
        
    
        
            <li > <a href="/categories/Collection.html">Collection</a></li>
        
    
</ul>
    </div>
    <div class="r-box">
        <div class="article">
            <h1 class="title">图片预加载探究</h1>            
            <p>I belong to : Experience</p>
            <hr/>
            <pre><code>
    /**
     * 预加载
     * @param {Array} dataList  预加载数据
     * @param {Array} attrArray 预加载属性，可选
     */
    export function  preLoad(dataList,attrList){
      //若有指定对象属性
      let imgList = [];
      if(attrList){
        dataList.forEach(element =&gt; {
          attrList.forEach(attr=&gt;{
            if(element[attr]){
              const img = new Image();
              img.src = element[attr];
              imgList.push(img);

            } 
          })
        });
      }else{
        dataList.forEach(element =&gt; { 
          const img = new Image();
          img.src = element;
          imgList.push(img);       
        });
      }

      return imgList;
    }</code></pre><h2 id="测试浏览器：chrome、firefox"><strong>测试浏览器：chrome、firefox</strong></h2>
<blockquote>
<p>在Firefox下并没有from memory cache以及from disk cache的状态展现 相同的资源在chrome下是from
disk/memory cache，但是Firefox统统是304状态码
即Firefox下会缓存资源，但是每次都会请求服务器对比当前缓存是否更改，chrome不请求服务器，直接拿过来用</p>
</blockquote>
<blockquote>
<p>200 OK (from disk cache) 是浏览器没有跟服务器确认， 就是它直接用浏览器缓存。 304
是浏览器和服务器确认了一次缓存有效性，再用的缓存。客户端和服务器端只需要传输很少的数据量来做文件的校验，如果文件没有修改过，则不需要返回全量的数据。能够节省大量的网络带宽，并减少了页面的渲染时间。</p>
</blockquote>
<h1 id="图片img的预加载">图片img的预加载</h1>
<h2 id="方法一直接用src进行预加载但不保存">方法一:直接用src进行预加载,但不保存</h2>
<pre><code> &lt;img :src=&quot;data[current].imagePath&quot;&gt;
 mounted() {  
     preLoad(this.data,[&#39;imagePath&#39;]);
}</code></pre><p><strong>结果：</strong></p>
<ol>
<li><p>谷歌 切换图片速度快，确实有预加载. 初次 200  disk cache。</p>
<p>切换没有发XHR，发了Img。200 OK (from disk cache) 是浏览器没有跟服务器确认，即直接用浏览器缓存。</p>
</li>
</ol>
<ol start="2">
<li><p>火狐切换图片速度慢，并没有预加载 初次，没有“已缓存”标识。</p>
<p>第一次切换,还是发了请求</p>
<p>第二次切换，正常没有请求（默认情况下状态码为200的响应可以被缓存）。
所以火狐预加载并没有成功。</p>
</li>
</ol>
<hr>
<h2 id="方法二：-把预加载的挂载到data上（最好）">方法二： 把预加载的挂载到data上（最好）</h2>
<p><strong>结果：</strong>火狐、谷歌表现一致，都切换较快，没有发请求</p>
<pre><code>&lt;div ref=&quot;solution-img&quot;&gt;&lt;/div&gt;
mounted() {    
    this.preLoadImg = preLoad(this.data,[&#39;bgimagePath&#39;]);
}
methods: {
    changeActive(index) {
      this.current = index;
      let dom = this.$refs[&#39;solution-img&#39;];
      if(dom.childNodes.length &gt; 0) dom.removeChild(dom.childNodes[0]);
      dom.appendChild(this.preLoadImg[index]);
    }

  },</code></pre><h1 id="背景图片的预加载">背景图片的预加载</h1>
<p><strong>不做任何处理结果</strong>：第一次请求返回200。第一次加载后都是304</p>
<hr>
<h2 id="方法一-：使用css预加载">方法一 ：使用css预加载</h2>
<pre><code>#preload-01 { background:  url(&#39;~@/assets/img/market/icon-00.png&#39;) no-repeat -9999px -9999px; }    
#preload-02 { background:  url(&#39;~@/assets/img/market/icon-01.png&#39;) no-repeat -9999px -9999px; }    </code></pre><p><strong>结果：</strong> 和不处理表现一致。初次加载也没有请求这些图片。</p>
<h2 id="方法二：src预加载，但不保存">方法二：src预加载，但不保存</h2>
<pre><code>{
 background-image: url(&#39;~@/assets/img/market/icon-10.png&#39;)  ;       
 &amp;:hover{  background-image:url(&#39;~@/assets/img/market/icon-11.png&#39;)}
}
myPreLoad(){
      let images = [  
        require(&#39;@/assets/img/market/icon-10.png&#39;),
        require(&#39;@/assets/img/market/icon-11.png&#39;),
      ];
      preLoad(images);</code></pre><p>   }</p>
<p><strong>结果：</strong> 第一次hover 状态码304。之后切换没有发请求。火狐和谷歌表现一致，都是304</p>
<h2 id="方法三：把预加载的挂载到data上">方法三：把预加载的挂载到data上</h2>
<pre><code>handleMouseenter(index){
this.getDom(index).style.backgroundImage = &quot;url(&quot; +this.preLoadImage[index*2+1].src + &quot;)&quot;;

},</code></pre><p><strong>结果：</strong> 谷歌切换没有发请求。但是火狐会发请求，并返回304。</p>
<h2 id="方法四：雪碧图（最好）">方法四：雪碧图（最好）</h2>
<pre><code>.backgroud-box{
  width: 137px ;
  height: 113px;
  background-image: url(&#39;./icon-1.png&#39;) ;    
  background-position-x:100%;
  background-position-y:0;
}

&amp;:hover&gt;.backgroud-box { background-position-y:-113px;} </code></pre><p>以上方法都会出现切换背景图片闪烁。用这个方法位移背景就不会。而且第一次加载就把图片下载下来了，切换也不会发请求，因为用的是同一张图</p>
<h1 id="个人结论">个人结论</h1>
<p>1、因为</p>
<blockquote>
<p>在Firefox下并没有from memory cache以及from disk cache的状态展现。 相同的资源在chrome下是from
disk/memory cache，但是Firefox统统是304状态码</p>
</blockquote>
<p>所以火狐下每次操作到src或者url都要发出请求。</p>
<p>2、刚好<img>标签是一个Image对象，可以直接插入html，所以可以保存在data上缓存。304请求虽然也是可以缩短渲染时间，但是直接保存在data上可以免去一次请求，响应时间更快。</p>
<p>3、背景图片涉及到改变url，所以没办法直接用保存在data上的数据。</p>

        </div>
    </div>
    
</body>
<script type="text/javascript">
    //文章里面的外链都打开新窗口    
    var alist = document.querySelectorAll(".article a");
    for(let i=0;i<alist.length;i++) if(alist[i].href.indexOf('#') < 0) alist[i].target="_blank"    
</script>
</html>