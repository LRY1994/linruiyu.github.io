<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/static/favicon.ico" type="image/x-icon"/>
    <link rel="stylesheet" href="/static/css/all.css" />
    <title>大脸圆玉的博客</title>
</head>
<body>
    <div class="l-nav">
        <div class="nav-img">
    <img src="/static/img/avatar.png"/>
</div>


<ul>
    
        
            <li class="li-active"> <a href="/categories/Experience.html">Experience</a></li>
        
        
            <li > <a href="/categories/Reading.html">Reading</a></li>
        
    
        
            <li > <a href="/categories/Collection.html">Collection</a></li>
        
    
</ul>
    </div>
    <div class="r-box">
        <div class="article">
            <h1 class="title">2018遇到的问题</h1>            
            <p>I belong to : Experience</p>
            <hr/>
            <h2 id="20182">2018/2</h2>
<h3 id="火狐和ie下-javascriptvoid0-会弹出空白页">火狐和IE下 javascript:void(0) 会弹出空白页</h3>
<p>本来javascript:void(0);的用处是不用整体刷新网页且返回一个空值，但这儿由于DOM本身的冒泡事件所以会最后执行HREF属性内的javascript:void(0);导致执行函数返回了一个空值，所以覆盖掉了前面正常执行函数所返回的值引起的错误。</p>
<p>一般情况下，IE会先运行DOM本身绑定的事件，如ONCLICK;如果没有阻止冒泡，则会顺序执行HREF属性。如果想正确运行，可以在前面用RETURN FALSE终止冒泡，例如：</p>
<pre><code>&lt;a target=&quot;_blank&quot; class=&quot;prev&quot; onclick=&quot;return false;&quot;   href=&quot;javascript:void(0);&quot;&gt;&lt;/a&gt;</code></pre><p>或者直接删去也行，如：</p>
<pre><code>&lt;a target=&quot;_blank&quot;  class=&quot;prev&quot; &gt;&lt;/a&gt;</code></pre><p>但是后者hover的时候没有手势的pointer</p>
<h3 id="vue2父组件传递props异步数据到子组件，获取到的是undefined">vue2父组件传递props异步数据到子组件，获取到的是undefined.</h3>
<p>解决方法<a href="http://www.jb51.net/article/117447.htm">参考链接</a></p>
<ol>
<li>最简单的解决方法：使用v-if</li>
<li>子组件使用watch来监听父组件改变的prop，使用methods来代替created</li>
<li>子组件watch computed data 相结合，有点麻烦</li>
<li>使用emit，on，bus相结合（使用了bus库）</li>
<li>vuex结合computed、mapState或者合computed、mapGetters</li>
</ol>
<h3 id="对象的属性名称可以是变量吗？">对象的属性名称可以是变量吗？</h3>
<p>可以，运用方括号法设置就是。如</p>
<pre><code>var a = &quot;name&quot;;
var b = 10;
var obj = {};
obj[a] = b;</code></pre><h3 id="后台给的服务链接直接插入html中img的src里">后台给的服务链接直接插入html中img的src里</h3>
<p>修改图片之后，因为src的内容一直都是后台服务链接，是个不变的值，所以不会重新去请求，图    片会一直不变。如果刷新页面这个链接返回的图片会改变，为了做到点击图片只重载这个src而整个页面不刷新，采用的方法是在后面加上          Math.random()，例如 </p>
<pre><code>`http:${this.baseURL}gw/app.get.logo?tenantId=${this.tenantId}&amp;appId=${this.appId}?`+Math.random();</code></pre><h3 id="扩展运算符可以用于数组深拷贝">扩展运算符可以用于数组深拷贝</h3>
<pre><code>var arr2 = arr;
var arr3 = [...arr];
console.log(arr===arr2); //true, 说明arr和arr2指向同一个数组
console.log(arr===arr3); //false, 说明arr3和arr指向不同数组</code></pre><h3 id="number-的修饰符">.number 的修饰符</h3>
<p>数字类型的验证需要在 v-model 处加上 .number 的修饰符，这是 Vue 自身提供的用于将绑定值转化为 number 类型的修饰符。              v-model.number只会截取数字部分，比如100ttt只会取前面的100。做修改操作的时候这种情况用自定义validator解决</p>
<h2 id="20183">2018/3</h2>
<h3 id="给点击路由的时候加上监听事件">给点击路由的时候加上监听事件</h3>
<pre><code class="language-html">&lt;router-link class=&quot;my-link&quot; :to=&quot;{name: &#39;main.provider.index&#39;, params: {providerId: scope.row.providerId}}&quot;&gt;提供者主页&lt;/router-link&gt;</code></pre>
<p>解决方法：给组件绑定原生事件。有时候，你可能想在某个组件的根元素上监听一个原生事件。可以使用 v-on 的修饰符 .native。例如：</p>
<pre><code>&lt;my-component v-on:click.native=&quot;doTheThing&quot;&gt;&lt;/my-component&gt;</code></pre><p>参考连接
<a href="https://segmentfault.com/q/1010000007896386">给组件绑定原生事件</a></p>
<h3 id="块内元素文字上下居中">块内元素文字上下居中</h3>
<p>line-height设置为height的值</p>
<h3 id="用refs来组件通信">用refs来组件通信</h3>
<p>在讨论非父子通信的时候，并在没有用Vuex的情况下，我是用官网那种创建Vue实例的方法，但是同事提到了另一种方法
用refs来引用，不禁一想这好像也是一种解决方案，就是觉得怪怪的。在这里记录一下</p>
<h3 id="关于第4点，今天工作用了thisrefs来传播事件，类似于brocast但是vue2把brocast废除了。">关于第4点，今天工作用了this.$refs来传播事件，类似于$brocast,但是VUE2把$brocast废除了。</h3>
<p>总结一下vue传播事件</p>
<p>(1) 子组件传播事件给父组件，用<code>$on,$emit</code>.</p>
<p>虽然说是这样说，但是不是直接在父组件里面写$on的,应该是这样</p>
<pre><code class="language-html">&lt;parent&gt;
    &lt;child @eventname=&quot;event&quot;&gt;
&lt;/parent&gt;</code></pre>
<p>然后在parent组件里面写 event函数.event(){}</p>
<p>子组件调用的时候用<code>this.$emit(&#39;eventname&#39;,payload)</code></p>
<p>(2)父组件传播事件给子组件，用 <code>$refs</code></p>
<pre><code class="language-html">&lt;parent&gt;
    &lt;child ref=&quot;refname&quot;&gt;
&lt;/parant&gt;</code></pre>
<p>调用的时候用<code>this.$ref[&#39;refname&#39;].eventname()</code></p>
<p>(3)上面有种都麻烦的话，创建实例bus</p>
<h3 id="js的数组可以是这样的形式">js的数组可以是这样的形式</h3>
<p><code>(4) [{…}, {…}, {…}, {…}, total: 4, code: &quot;core.ok&quot;]</code></p>
<p>他的length是4</p>
<h3 id="把字符串转换成数字可以用数字运算符但是--不行">把字符串转换成数字可以用数字运算符,但是 + 不行</h3>
<pre><code class="language-javascript">console.log(&quot;2&quot;&gt;&gt;&gt;0)  //2 number 
console.log(&quot;2&quot;&gt;&gt;0)  //2 number 
console.log(&quot;2&quot;&lt;&lt;0)  //2 number  没有（&lt;&lt;&lt;）
console.log(&quot;2&quot;- 0)    //2 number
console.log(&quot;2&quot;+0)    //20 string</code></pre>
<h3 id="reduce函数好好用">reduce函数好好用</h3>
<p>今天写了一个有重大作用的reduce函数，好开心。在此纪念一下</p>
<pre><code class="language-javascript">//str {String}, &quot;app.get.logo.list&quot;
//ctx {Object},  this._$http
//return {Object}, this._$http.app.get.logo.list
 getBackend(str){
        const arr = this.loadBackend.split(&#39;.&#39;);
        let ctx= this._$http;
        let a;
        let b=arr.reduce((prev, cur, idx) =&gt; {                
              a = prev[cur] ;         
            return a;
        },ctx);              
          return b;      
      }</code></pre>
<h3 id="vue项目中全局引入scss文件的方法">vue项目中全局引入scss文件的方法</h3>
<pre><code class="language-shell">npm install node-sass --save-dev
npm install sass-loader --save-dev
npm install sass-resources-loader --save-dev</code></pre>
<p>修改build/utils.js</p>
<pre><code class="language-javascript">scss: generateLoaders(&#39;sass&#39;).concat(
      {
        loader: &#39;sass-resources-loader&#39;,
        options: {
          resources: path.resolve(__dirname, &#39;../src/assets/your.scss&#39;)
        }
      }
    )</code></pre>
<h3 id="elementui的layout问题">elementUI的layout问题</h3>
<p>el-footer会直接fixed在窗口底部，不好看，</p>
<p>解决方法：el-footer放到el-main里面</p>
<pre><code class="language-html">&lt;el-container style=&quot;height:100%;&quot;&gt;
    &lt;el-header class=&quot;header&quot; style=&quot;height:100px&quot;&gt;
        &lt;cty-navbar :navs=&quot;navs&quot;&gt;&lt;/cty-navbar&gt;
    &lt;/el-header&gt;

    &lt;el-main&gt;      
        &lt;el-scrollbar wrap-style=&quot;overflow-x:hidden;&quot; style=&quot;min-height: 800px&quot;&gt;
            &lt;div&gt;
                &lt;router-view&gt;&lt;/router-view&gt;
            &lt;/div&gt;           
        &lt;/el-scrollbar&gt;

        &lt;el-footer class=&quot;footer&quot; style=&quot;height:70px&quot;&gt;
            &lt;cty-footer&gt;&lt;/cty-footer&gt;
        &lt;/el-footer&gt;
    &lt;/el-main&gt;

&lt;/el-container&gt;</code></pre>
<h3 id="vue路由刷新问题，两个路由对应一个组件，如何能让路由重载">vue路由刷新问题，两个路由对应一个组件，如何能让路由重载</h3>
<p><a href="https://segmentfault.com/q/1010000010844655">https://segmentfault.com/q/1010000010844655</a></p>
<p>写在共用组件文件里</p>
<pre><code class="language-javascript">data(){
...
}
mounted(){...},
 watch: {          
            $route: {
                handler: function (val, oldVal) {
                    this.worksheet_type = this.$route.params.type;                     
                },
                deep: true
            }
        },</code></pre>
<p>在共用组件上加上key
<code>&lt;div :key=&quot;$route.path&quot;&gt;</code></p>
<h3 id="单行文本超出隐藏并显示省略号">单行文本超出隐藏并显示省略号</h3>
<pre><code class="language-css">.element{
width: 20em;/*不允许出现半汉字截断*/
overflow: hidden; /*自动隐藏文字*/
text-overflow: ellipsis;/*文字隐藏后添加省略号*/
white-space: nowrap;/*强制不换行*/</code></pre>
<h3 id="多行文字隐藏加省略号">多行文字隐藏加省略号</h3>
<pre><code class="language-css">.element{
    width: 20em;
    height: 3em;/*注意高度和宽度，不允许出现半汉字截断*/
    line-height: 1.5em;
    overflow: hidden;
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
}</code></pre>
<h2 id="20184">2018/4</h2>
<h3 id="实现qq弹窗-和qq号为qqnum聊天">实现QQ弹窗 和QQ号为qqnum聊天</h3>
<pre><code class="language-html">&lt;a target=&quot;_blank&quot; :href=&quot;`http://wpa.qq.com/msgrd?v=3&amp;uin=${qqnum}&amp;site=qq&amp;menu=yes`&quot;&gt;
    &lt;img border=&quot;0&quot; :src=&quot;`http://wpa.qq.com/pa?p=2:1424314130:51`&quot; alt=&quot;点击这里给我发消息&quot; title=&quot;点击这里给我发消息&quot;/&gt;
&lt;/a&gt;</code></pre>
<h3 id="vue全局过滤器也可以当函数使用">Vue全局过滤器也可以当函数使用</h3>
<pre><code class="language-javascript">this.$options.filters.dateformat</code></pre>
<h3 id="字符串转义问题">字符串转义问题</h3>
<p>本地字符串不会自己转义，所以本地需要写成 <code>\\d</code></p>
<p>后台请求返回的字符串会自动帮你转义，所以在后台数据库只需要写成<code>\d</code></p>
<h3 id="如何解决vue父组件模板slot到孙子组件中去">如何解决vue父组件模板slot到孙子组件中去</h3>
<pre><code>&gt;每一个被继承的组件都需要有slot;</code></pre><p><a href="https://segmentfault.com/q/1010000012141592">参考链接</a></p>
<h3 id="记录一下第一次使用async-await-解决了困扰我一早上的异步问题赞！！！">记录一下第一次使用async ,await ,解决了困扰我一早上的异步问题,赞！！！</h3>
<pre><code class="language-javascript">   //获取文件信息
    getFileInfo(item){
        let fileId= item.value;
        const downloadLink =`/gw/tenant/worksheet/extend/Download?worksheetInfoId=${item.worksheetInfoId}&amp;blobId=offer.info`;
        return new Promise((resolve,reject)=&gt;{
            if(fileId == &#39;undefined&#39;) resolve(null);
            this._$http.tenant.offerExtendGetFileInfo({fileId: fileId})
            .then(res=&gt;{ 
                res={...res,downloadLink};
                resolve(res)
            }) 
        })           
    },
    //获取文件信息
    fileGetter: async function(item) {           
        const fileInfo = await this.getFileInfo(item);
        return Promise.resolve(fileInfo);         
    },</code></pre>
<h3 id="自定义指令---解决跟dom有关的问题">自定义指令---解决跟dom有关的问题</h3>
<p>最大的用处就是可以引用一些第三方的代码插入到Vue项目中，比如有一个操作dom的函数：</p>
<pre><code class="language-javascript">//当然，真实情况第三方的代码要复杂的多
function changeColor(dom){
    dom.style.backgroundColor = &quot;red&quot;;
}</code></pre>
<p>我们可以注册一个全局的指令来为需要执行changeColor方法的dom提供指令：</p>
<pre><code class="language-javascript">Vue.directives(&#39;color&#39;,{
    bind:function(el){
        changeColor(el)
    }
})</code></pre>
<p>这样，如果需要这个dom改变颜色的话，只需要这样即可：
<code>&lt;div v-color&gt;改变颜色&lt;/div&gt;</code></p>
<p>当日常开发遇到跟dom有关的问题却一筹莫展时，可以想想自定义指令是否有功能可以解决为题</p>
<h3 id="父组件给子组件传值，这个值还要从子组件传给它的子组件【inheritattrs】和【attrs】">父组件给子组件传值，这个值还要从子组件传给它的子组件【inheritAttrs】和【attrs】</h3>
<p>直接一层一层传prop非常麻烦.
Vue提供了【inheritAttrs】和【attrs】两个功能来解决这样的问题</p>
<pre><code>//父组件
&lt;template&gt;
   &lt;div&gt;
     &lt;child :text=&quot;text&quot;  :count=&quot;count&quot;&gt;&lt;/child&gt;
   &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default{
        data(){
            return {
                text:&quot;父组件的值&quot;，
                count:123456，
            }
        }
    }
&lt;/script&gt;</code></pre><pre><code>//子组件
&lt;template&gt;
    &lt;div&gt;{{text}}&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default{
        props:[&quot;text&quot;]
    }
&lt;/script&gt;</code></pre><p>这里父组件的count属性仅仅挂在子组件上，并没有使用。此时我们打开浏览器，可以看到子组件的dom上显示的展示了<code>&lt;div class=&#39;child&#39; count=&quot;123456&quot;&gt;&lt;/div&gt;</code>。</p>
<p>此时，我们可以通过设置inheritAttrs: false来取消这种默认行为：</p>
<pre><code class="language-javascript">data(){
  return{
    ......   
  }  
}

inheritAttrs: false,
mounted(){
　　console.log(this.$attrs); //{count:123456}
}</code></pre>
<p>这时再看dom上就没有count属性了。然后，我还打印了this.$attrs的值，值为一个包含着count键值对的Object。
也就是说，<code>父组件没有props的属性值会被保存在一个名为$attrs中供子组件使用</code>，然而这并没有解决开头子组件的子组件获取值的问题。
别急，我们只需要在子组件上加个东西就可以了：</p>
<pre><code>&lt;template&gt;
    &lt;div class=&quot;child&quot;&gt;
        &lt;my-child v-bind=&quot;$attrs&quot;&gt;&lt;/my-child&gt;
    &lt;/div&gt;
&lt;/template&gt;</code></pre><p>这样，子组件的子组件也可以获取这个值了。</p>
<h3 id="provide--inject--更适合用来做父组件给后代组件传值，">provide / inject -更适合用来做父组件给后代组件传值，</h3>
<p>provide/inject方法要比inheritAttrs/attrs更适合用来做父组件给子组件或孙组件传值，
<a href="https://cn.vuejs.org/v2/api/#provide-inject">文档的链接</a></p>
<pre><code>//父组件使用provide
&lt;template&gt;  
    &lt;div class=&quot;parent&quot;&gt;     
         &lt;child-component&gt;&lt;/child-component&gt;   
    &lt;/div&gt;  
&lt;/template&gt;

&lt;script&gt;
export default {  
    ......  
    provide: { parent: &quot;父组件的值&quot;},  
    components:{    child-component,  }, 
     ......
&lt;/script&gt;


//此时可以在子组件通过这种方式获取父组件中“parent”的值：
//子组件中
export default {  
    mounted(){      
        console.log(this.parent); //&quot;父组件的值&quot;  
    },  
    inject: [&#39;parent&#39;],
}</code></pre><p>2018/5</p>
<h3 id="发现三个很厉害的库">发现三个很厉害的库</h3>
<p><code>htmlDocx</code> (将html代码导出为doc文件)<a href="http://evidenceprime.github.io/html-docx-js/build/html-docx.js">http://evidenceprime.github.io/html-docx-js/build/html-docx.js</a> 
<code>saveAs</code>(将浏览器内存中的doc文件保存至硬盘)<a href="http://evidenceprime.github.io/html-docx-js/test/vendor/FileSaver.js">http://evidenceprime.github.io/html-docx-js/test/vendor/FileSaver.js</a>
<code>domtoimage</code>(将dom节点转化成为图片)<a href="https://cdnjs.cloudflare.com/ajax/libs/dom-to-image/2.6.0/dom-to-image.min.js">https://cdnjs.cloudflare.com/ajax/libs/dom-to-image/2.6.0/dom-to-image.min.js</a></p>
<p>domtoimage.toPng(dom); //转出来是base64
saveAs(htmlDocx.asBlob(html), filename); </p>
<p>主要这三个库方法
domtoimage.toPng
saveAs
htmlDocx.asBlob  </p>
<h3 id="vue的router的push传递参数有没有不把参数展示在url中的传递方式？">Vue的router的push传递参数有没有不把参数展示在url中的传递方式？</h3>
<pre><code class="language-javascipt">const userId = 123
router.push({ name: &#39;user&#39;, params: { userId }})
// 路由设置 path 为：&#39;/user/:userId&#39;
// 跳转路径：&#39;/user/123&#39;

// 路由设置 path 为：&#39;/user&#39;
// 跳转路径：&#39;/user&#39;
// this.$route.params.userId 获取userId</code></pre>
<h2 id="20186">2018/6</h2>
<h3 id="使用keep-alive">使用keep-alive</h3>
<p>在商品列表进入商品详情页之后
<a href="https://www.cnblogs.com/nokelong/p/8124513.html">vue中使用keepAlive组件缓存遇到的坑</a></p>
<h3 id="a标签里面不加download属性会下载下来一些莫名其妙的东西">a标签里面不加download属性会下载下来一些莫名其妙的东西</h3>
<pre><code class="language-html">&lt;a :href=&quot;file.worksheetFileId|url&quot;  :download=&quot;file.fileName&quot;&gt;{{file.fileName}}&lt;/a&gt;</code></pre>
<p>html5对a标签新增的download属性用于下载文件，简单的理解是a标签如果添加了download属性，那么点击它的时候就不会跳转，而是会触发浏览器下载文件。
那么我不加download属性会下载下来的东西是什么？？</p>
<p>答案：docx后缀的word文档用解压软件打开就是这个目录结构</p>
<h3 id="nexttick">$nextTick</h3>
<p>Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。
$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 。</p>
<h3 id="router-link存在的问题是，手动输入改变url，下面路由没监听到">router-link存在的问题是，手动输入改变url，下面路由没监听到</h3>
<p> vue-router在IE 11下有bug,a href 里的路径，点击地址栏发生了变化，页面并不跳转
vm._route.path并没有发生变化，和地址栏不同步
要加上这段代码修正下：</p>
<pre><code class="language-javascript">function fixRouterIE(vm){
    //IE 11下
    if (
      &#39;-ms-scroll-limit&#39; in document.documentElement.style &amp;&amp; 
      &#39;-ms-ime-align&#39; in document.documentElement.style
    ) { 
      window.addEventListener(&quot;hashchange&quot;, function(event) {
        const currentPath = window.location.hash.slice(1);

        if (vm._route.path !== currentPath) {
          vm._router.push(currentPath)
        }
      }, false)
    }
}</code></pre>
<h3 id="height设为100要求父容器高度确定，否则无效。">height设为100%要求父容器高度确定，否则无效。</h3>
<h3 id="el-scrollbar滚动到容器底部">el-scrollbar滚动到容器底部</h3>
<pre><code>&lt;el-scrollbar style=&quot;height:100%&quot; ref=&quot;elscrollbar&quot;&gt;
var div = this.$refs[&#39;elscrollbar&#39;].$refs[&#39;wrap&#39;];
this.$nextTick(() =&gt; {
    div.scrollTop = div.scrollHeight
})</code></pre><h3 id="怎么应用vertical-align，才能生效？">怎么应用vertical-align，才能生效？</h3>
<p><a href="https://blog.csdn.net/diudiu5201/article/details/54666809">怎么应用vertical-align，才能生效</a></p>
<ol>
<li><p>父元素（inline-block\block）必须含有line-height（inline元素有无皆可），子元素（inline-block/inline元素）中的vertical-align才能起作用。
vertical-align不可继承，必须对子元素单独设置。</p>
</li>
<li><p>当父元素没有设置line-height时，vertical-align只对行内元素的兄弟元素对齐有用，无法子元素居中对齐父元素。
设置了vertical-align:middle的子元素的中线与兄弟元素的基线对齐。若兄弟元素都设置该项，则居中对齐。</p>
</li>
</ol>
<h3 id="arrayprototypesort-兼容">Array.prototype.sort 兼容</h3>
<p>IE9-- Array.prototype.sort 不能根据 对象属性 做排序的遗憾 </p>
<pre><code class="language-javascript">//方法1冒泡排序
var mySort = function(fn){
    if(typeof fn != &#39;function&#39;){
        fn = function(a,b){
            return a-b;
        }
    }

    for(var i=0; i &lt; this.length-1;i++){
        for(var j=i+1;j&lt;this.length;j++){
            var t = this[i];
            if(fn(this[i],this[j]) &gt; 0){
                this[i] = this[j];
                this[j] = t;
            }
        }
    }
    return this;
}

if(typeof Array.prototype.sorts!= &#39;fucntion&#39;){
    Array.prototype.sorts = mySort;
    mySort = null;
}


//方法2 插入排序
var mySort = function(fn){
    if(typeof fn != &#39;function&#39;){
        fn = function(a,b){
            return a-b;
        }
    }
    for(var i=1;i&lt;this.length;i++){
        var t = this[i];
        var j = i-1;
        while(j &gt;= 0 &amp;&amp; fn(this[j],t)&gt; 0 ){
            this[j+1] = this[j];
            j--;
        }
        this[j+1] = t;

    }
    return this;

}
if(typeof Array.prototype.sorts!= &#39;fucntion&#39;){
    Array.prototype.sorts = mySort;
    mySort = null;
}</code></pre>
<p>safari 不支持函数参数 </p>
<pre><code class="language-javascript">!function(window){ 
    var ua = window.navigator.userAgent.toLowerCase(), 
    reg = /msie|applewebkit.+safari/; 
    if(reg.test(ua)){ 
        var _sort = Array.prototype.sort; 
        Array.prototype.sort = function(fn){ 
            if(!!fn &amp;&amp; typeof fn === &#39;function&#39;){ 
                if(this.length &lt; 2) return this; 
                var i = 0, j = i + 1, l = this.length, tmp, r = false, t = 0; 
                for(; i &lt; l; i++){ 
                    for(j = i + 1; j &lt; l; j++){ 
                        t = fn.call(this, this[i], this[j]); 
                        r = (typeof t === &#39;number&#39; ? t : 
                        !!t ? 1 : 0) &gt; 0 
                        ? true : false; 
                        if(r){ 
                            tmp = this[i]; 
                            this[i] = this[j]; 
                            this[j] = tmp; 
                        } 
                    } 
                } 
                return this; 
            }else{ 
                return _sort.call(this); 
            } 
        }; 
    } 
}(window); </code></pre>
<p><a href="https://blog.csdn.net/lt3487928/article/details/53157817">https://blog.csdn.net/lt3487928/article/details/53157817</a></p>
<p><a href="https://www.cnblogs.com/Alucelx/archive/2011/07/13/2104381.html">https://www.cnblogs.com/Alucelx/archive/2011/07/13/2104381.html</a></p>
<h2 id="20187">2018/7</h2>
<h3 id="vue强制更新">vue强制更新</h3>
<p>用vue.$set不行，watch不行，试试$forceUpdate。
还有一种办法，再把值重新复制一遍也是可以的
<code>this.obj = Object.assign({},this.obj)</code></p>
<h3 id="在vue中使用sass及sass图片路径问题">在Vue中使用sass及sass图片路径问题</h3>
<p><a href="https://www.jianshu.com/p/5e81814f8d8c">https://www.jianshu.com/p/5e81814f8d8c</a></p>
<h3 id="cors跨域请求">CORS跨域请求</h3>
<p>会先发option请求，如果server返回access-control-allow-origin头为*或者和当前域名一致的话，才会进入第二段的真正请求。</p>
<h3 id="禁止缓存数据deactivated">禁止缓存数据deactivated</h3>
<p> 防止下次选择数据不更新</p>
<pre><code class="language-js">  deactivated () {
    this.$destroy(true)
  }</code></pre>
<h3 id="深拷贝">深拷贝</h3>
<p> <code>arr.slice()</code>
 如果obj所有值都是非引用类型，那么obj.slice(0)与深浅拷贝没有差别；</p>
<p>如果obj有引用类型的元素的话，obj.slice(0)仅仅是复制了元素的地址，，obj.slice(0)可看作浅拷贝。</p>
<p>对象深拷贝 <code>Object.assign({},obj)</code>,不要用JSON.parse(JSON.stringify(obj)),太慢</p>
<h3 id="事件冒泡到父容器或某个祖先容器停止">事件冒泡到父容器或某个祖先容器停止</h3>
<p>在父容器或某个祖先容器上绑定一个<code>@click.stop=&#39;stop&#39;</code>
stop函数为一个空函数即可</p>
<h2 id="201810">2018/10</h2>
<h3 id="webpack-dev-server启动">webpack-dev-server启动</h3>
<p>并不是访问vue项目内某个文件, src/assets内的文件是不能在index.html直接引用的, 必须经过loader处理路径</p>
<p>plublic里放置的文件是不经过 webpack 处理的。在 index.html 里引用的时候，直接就是 <code>&lt;script src=&quot;/plublic/oidc-client.js&quot;&gt;&lt;/script&gt;。</code></p>
<h3 id="scss-export">scss export</h3>
<pre><code class="language-scss">
 $title-width: 100;

:export {
  titleWidth: $title-width;
}</code></pre>
<h3 id="ie-margin-top负值无效">ie margin-top负值无效</h3>
<p><a href="https://www.cnblogs.com/chaozhang/p/4711282.html">https://www.cnblogs.com/chaozhang/p/4711282.html</a></p>
<p>加上display:inline-block</p>
<h3 id="inline-block的元素设置over-flowhidden会意外地增加元素总体高度，">inline-block的元素设置over-flow:hidden会意外地增加元素总体高度，</h3>
<p>用vertical-align:bottom解决</p>
<h3 id="ie中img被拉伸">ie中img被拉伸</h3>
<p>只要设置img为 height:auto，width:auto，就不会出现这种情况了</p>
<h3 id="vue-路由query变化监测不到meta的">vue 路由query变化监测不到meta的</h3>
<p>这样使用query,路由变化，meta并没有变化</p>
<pre><code class="language-js">{
    name: &#39;order.list.1&#39;,
    path: &#39;/order/list/status=1&#39;,
    component: list,
    meta: {
      domain: &#39;order&#39;,
      key: &#39;order-list-1&#39;,
    },
  },

  {
    name: &#39;order.list.2&#39;,
    path: &#39;/order/list/status=2&#39;,
    component: list,
    meta: {
      domain: &#39;order&#39;,
      key: &#39;order-list-2&#39;,
    },
  },</code></pre>
<p>使用params是可以的</p>
<pre><code class="language-js">{
    name: &#39;order.list.1&#39;,
    path: &#39;/order/list/1&#39;,
    component: list,
    meta: {
      domain: &#39;order&#39;,
      key: &#39;order-list-1&#39;,
    },
  },

  {
    name: &#39;order.list.2&#39;,
    path: &#39;/order/list/2&#39;,
    component: list,
    meta: {
      domain: &#39;order&#39;,
      key: &#39;order-list-2&#39;,
    },
  },</code></pre>
<p>使用函数模式也可以</p>
<pre><code class="language-js">const dict = {
  1: &#39;order-list-1&#39;,
  2: &#39;order-list-2&#39;,
  default: &#39;order-list&#39;,
};


export default{
  name: &#39;order&#39;,
  path: &#39;/order&#39;,
  redirect: {
    name: &#39;order.list&#39;,
  },
  component: Container,
  children: [{
    name: &#39;order.list&#39;,
    path: &#39;/order/list&#39;,
    component: list,
    meta: {
      domain: &#39;order&#39;,
      key(route) {
        return dict[route.query.status || &#39;default&#39;];
      },
    },
  },</code></pre>
<h3 id="vue-指令使用模板，不再用template了，用el">vue 指令使用模板，不再用template了，用el</h3>
<pre><code class="language-js">//Marquee.js
import Marquee from &#39;./Marquee.vue&#39;;
const Tpl = Vue.extend(Marquee);//这个好漂亮
const Plugin = {
  install(vue, options) {
        Vue.directive(&#39;marquee&#39;, {
           inserted(el, binding, vnode) {
              const mask = new Tpl({
                  el: document.createElement(&#39;div&#39;),
                  data: { name: binding.value }
              });
              el.appendChild(mask.$el);
           })
     }   
  }
}
export default Plugin;
//main.js
import Marquee from &#39;./Marquee.js&#39;
Vue.use(Marquee)</code></pre>
<h2 id="201812">2018/12</h2>
<h3 id="完美解决本地和服务器上资源url解析的问题">完美解决本地和服务器上资源url解析的问题</h3>
<p>在 config/index.js 中修改 assetsPublicPath 为 ./
在 build/utils.js 中的 ExtractTextPlugin.extract 传入参数 publicPath: &#39;../../&#39;</p>
<h2 id="知识记录">知识记录</h2>
<h3 id="forfor-infor-eachfor-of">for\for-in\for-each\for-of</h3>
<p>for-in不仅可以遍历数组还可以遍历对象
for-in 遍历属性的顺序并不确定，即输出的结果顺序与属性在对象中的顺序无关，也与属性的字母顺序无关，与其他任何顺序也无关。
使用for-in在遍历的时候，它不仅遍历了对象上的属性，而且还遍历了对象父类原型上的属性。
所以for-in并不适合遍历Array中的元素，更适合遍历对象中的属性
for-in只会遍历存在的实体,以及对应的原型链上的属性.因此其速度相比较其他for循环，要慢一些。
所以除非明确要迭代一个属性数量未知的对象，否则应该避免使用for-in。
for-in遍历数组的缺点：数组的下标index值是数字，for-in遍历的index值&quot;0&quot;,&quot;1&quot;,&quot;2&quot;等是字符串</p>
<p>在不同浏览器下测试的结果都是 forEach 的速度不如 for。
forEach主要应用在遍历数组，但是它的性能并不如for，因此可以使用for就尽量不要使用forEach。
<strong>forEach 不能break 或者return</strong></p>
<p><strong>for-of不支持普通对象遍历，只返回具有数字索引的属性</strong>.</p>
<p>遍历数组：for-of &gt; for &gt; for-each
遍历对象：for-in(要用hasOwnProperty)
await/async 要用for-of
for循环、while循环、do-while循环比for in 要快</p>
<h3 id="字符串-拼接性能">字符串 拼接性能</h3>
<p>比较下四中字符串拼接方法的性能：</p>
<pre><code>A：str = str + &#39;a&#39;+&#39;b&#39;
B:str += &#39;a&#39; + &#39;b&#39;
C: arr.join(&#39;&#39;)
D:str.concat(&#39;b&#39;,&#39;c&#39;)</code></pre><p>☆ Chrome65上测试的是A优于B优于C优于D</p>
<h3 id="总结一些常用的">总结一些常用的</h3>
<ol>
<li>内容长短不固定的时候用min-height,而不要用height</li>
<li>显示一行，多余的用省略号表示<pre><code class="language-css"> .one-line{
     overflow: hidden;
     text-overflow: ellipsis;
     white-space: nowrap;
     display: inline-block;
 }</code></pre>
 最多显示2行，多余的用省略号表示<pre><code class="language-css"> .two-line{     
     overflow: hidden;     
     display: -webkit-box;
     -webkit-box-orient: vertical;
     -webkit-line-clamp: 2;
     text-overflow: ellipsis;
 }</code></pre>
</li>
<li>一般英文或者数字是默认不换行，所以要加上<pre><code class="language-css"> word-break: break-all;</code></pre>
</li>
<li>placeholder<pre><code class="language-css">:-moz-placeholder { /* Mozilla Firefox 4 to 18 */
 color: #C6C6C6;
}
</code></pre>
</li>
</ol>
<p>::-moz-placeholder { /* Mozilla Firefox 19+ */
    color: #C6C6C6;
}</p>
<p>input:-ms-input-placeholder{
    color: #C6C6C6;
}</p>
<p>input::-webkit-input-placeholder{
    color: #C6C6C6;
}</p>
<pre><code>


### vue源码研读
[手拉手带你过一遍vue部分源码](https://juejin.im/post/5adff30f518825672d33d596)

[当面试官问你Vue响应式原理，你可以这么回答他](https://juejin.im/post/5adf0085518825673123da9a)

[如何解释vue的生命周期才能令面试官满意？](https://juejin.im/post/5ad10800f265da23826e681e)

在使用.vue文件开发的过程当中，我们在里面写了template模板，在经过了vue-loader的处理之后，就变成了render function，最终放到了vue-loader解析过的文件里面。这样做有什么好处呢？原因是由于在解析template变成render function的过程，是一个非常耗时的过程，vue-loader帮我们处理了这些内容之后，当我们在页面上执行vue代码的时候，效率会变得更高。

Vue为我们提供了renderError方法，这个方法只有在开发的时候它才会被调用，在正式打包上线的过程当中，它是不会被调用的。它主要是帮助我们调试render里面的一些错误。
```javascript
renderError (h, err) {
  return h(&#39;div&#39;, {}, err.stack)
}</code></pre><p>有且只有当render方法里面报错了，才会执行renderError方法。
所以我们主动让render函数报个错：</p>
<pre><code class="language-javascript">render (h) {
  throw new TypeError(&#39;render error&#39;)
}</code></pre>
<p>还有一点，renderError只有在<code>本组件</code>的render方法报错的情况下它才会被调用。</p>
<h3 id="cache-control">Cache-Control</h3>
<pre><code>no-cache: 告诉浏览器、缓存服务器，不管本地副本是否过期，使用资源副本前，一定要到源服务器进行副本有效性校验。
must-revalidate：告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。
max-age： 指缓存资源的缓存时间比指定的值小，那么客户端就接受缓存资源，且缓存服务器不对资源有效性进行再次确认</code></pre><h3 id="css像素">CSS像素</h3>
<p>是web编程的概念,是相对的而不是绝对的单位. 用户的缩放比会影响单位CSS像素点对应的实际物理像素的多少</p>
<h3 id="使用flexible实现手淘h5页面的终端适配">使用Flexible实现手淘H5页面的终端适配</h3>
<p>   <a href="https://github.com/amfe/article/issues/17">https://github.com/amfe/article/issues/17</a></p>
<h3 id="禁止使用documentwrite">禁止使用document.write()</h3>
<p>异步脚本禁止使用document.write()
延迟脚本禁止使用document.write()</p>
<h3 id="export及export-default的区别">export及export default的区别</h3>
<p>在一个文件或模块中，export可以有多个，export default仅有一个。 </p>
<ul>
<li>export</li>
</ul>
<p>(1) 导入的时候带花括号</p>
<pre><code>```javascript
    // 写法一
    export var m = 1;

    // 写法二
    var m = 1;
    export {m}; //export m 或者export 1都错误

    // 写法三
    var n = 1;
    export {n as m};
```</code></pre><p>(2) export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p>
<ul>
<li>export default </li>
</ul>
<p>(1) 导入的时候没有花括号</p>
<pre><code>```javascript
    import str from &#39;demo1&#39; //导入的时候没有花括号
```</code></pre><p>(2) export default命令的本质是将后面的值，赋给default变量，所以可以直接将一个值写在export default之后。</p>
<h3 id="用mpvue开发小程序了">用mpVue开发小程序了</h3>
<p><a href="https://www.itcodemonkey.com/article/2573.html">https://www.itcodemonkey.com/article/2573.html</a></p>

        </div>
    </div>
    
</body>
</html>