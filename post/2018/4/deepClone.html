<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/static/favicon.ico" type="image/x-icon"/>
    <link rel="stylesheet" href="/static/css/all.css" />
    <title>大脸圆玉的博客</title>
    <script>
        var alist = document.getElementsByTagName("a");
        for(let i=0;i<alist.length;i++) if(alist[i].href.indexOf('#') < 0) alist[i].target="_blank"    
    </script>
</head>
<body>
    <div class="l-nav">
        <div class="nav-img">
    <img src="/static/img/avatar.png"/>
</div>


<ul>
    
        
            <li > <a href="/categories/Experience.html">Experience</a></li>
        
    
        
            <li > <a href="/categories/Reading.html">Reading</a></li>
        
    
        
            <li class="li-active"> <a href="/categories/Collection.html">Collection</a></li>
        
</ul>
    </div>
    <div class="r-box">
        <div class="article">
            <h1 class="title">深度克隆</h1>            
            <p>I belong to : Collection</p>
            <hr/>
            <h2 id="第一种方法（只适用于基础类型）">第一种方法（只适用于基础类型）</h2>
<p> <code>const newObj = JSON.parse(JSON.stringify(oldObj));</code></p>
<h2 id="第二种方法">第二种方法</h2>
<p>实现对函数 、RegExp等特殊对象的克隆，保留对象的constructor,对象有循环引用也不会报错</p>
<p>参考 <a href="https://juejin.im/post/5abb55ee6fb9a028e33b7e0a">https://juejin.im/post/5abb55ee6fb9a028e33b7e0a</a></p>
<pre><code class="language-javascript">const getType = (obj)=&gt; {
    var toString = Object.prototype.toString;
    var map = {
        &#39;[object Boolean]&#39;  : &#39;boolean&#39;, 
        &#39;[object Number]&#39;   : &#39;number&#39;, 
        &#39;[object String]&#39;   : &#39;string&#39;, 
        &#39;[object Function]&#39; : &#39;function&#39;, 
        &#39;[object Array]&#39;    : &#39;array&#39;, 
        &#39;[object Date]&#39;     : &#39;date&#39;, 
        &#39;[object RegExp]&#39;   : &#39;regExp&#39;, 
        &#39;[object Undefined]&#39;: &#39;undefined&#39;,
        &#39;[object Null]&#39;     : &#39;null&#39;, 
        &#39;[object Object]&#39;   : &#39;object&#39;,
        &#39;[object Symbol]&#39;   : &#39;symbol&#39;
    };
    if(obj instanceof Element) {//因为对不同标签，toString会返回对应不同标签的构造函数
        return &#39;element&#39;;
    }
    return map[toString.call(obj)];
}

const getRegExp = re =&gt; {
  var flags = &#39;&#39;;
  if (re.global) flags += &#39;g&#39;;
  if (re.ignoreCase) flags += &#39;i&#39;;
  if (re.multiline) flags += &#39;m&#39;;
  return flags;
};

/**
* deep clone
* @param  {[type]} parent object 需要进行克隆的对象
* @return {[type]}        深克隆后的对象
*/
const deepClone = oldObj =&gt; {
  // 维护两个储存循环引用的数组
  const oldObjArr = [];
  const newObjArr = [];

  const clone = oldObj =&gt; { 

    let newObj, proto;

    const type = getType(oldObj);

    switch(type){
        case &#39;boolean&#39;:
        case &#39;number&#39;:
        case &#39;string&#39;:
        case &#39;null&#39;:
        case &#39;undefined&#39;:
        case &#39;function&#39;:{
            return oldObj;
            break;
        }
        case &#39;symbol&#39;:{
            return Symbol(Symbol.keyFor(oldObj).toString());
            break;
        }
        case &#39;array&#39;:{
            newObj = [];
            break;
        }
        case &#39;regExp&#39;:{
            newObj = new RegExp(oldObj.source, getRegExp(oldObj));
            if (oldObj.lastIndex) newObj.lastIndex = oldObj.lastIndex;
            break;
        }
        case &#39;date&#39;:{
            newObj = new Date(oldObj.getTime());            
            break;
        }
        //case &#39;obj&#39;:
        default:{
            // 处理对象原型
            proto = Object.getPrototypeOf(oldObj);
            // 利用Object.create切断原型链
            newObj = Object.create(proto);
            break;
        }
   }

   // 处理循环引用
   const index = oldObjArr.indexOf(oldObj);
   if (index != -1) {// 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象    
     return newObjArr[index];
   }

   oldObjArr.push(oldObj);
   newObjArr.push(newObj);

   for (let i in oldObj) {// 递归   ,这里数组和对象都可以用forin语句，但是数组使用forin会有一个问题，具体看最下面。但是这里不会影响  
     newObj[i] = clone(oldObj[i]);
   }

   return newObj;
 };


 return clone(oldObj);
}

/*
测试通过
*/
function person(pname) {
    this.name = pname;
}

const Messi = new person(&#39;Messi&#39;);

function say() {
    console.log(&#39;hi&#39;);
};

const oldObj = {
    a: say,
    b: new Array(1),
    c: new RegExp(&#39;ab+c&#39;, &#39;i&#39;),
    d: Messi
  };

  const newObj = deepClone(oldObj);

  console.log(newObj.a, oldObj.a); //[Function: say] [Function: say]
  console.log(newObj.b[0], oldObj.b[0]); // undefined undefined
  console.log(newObj.c, oldObj.c); // /ab+c/i /ab+c/i
  console.log(newObj.d.constructor, oldObj.d.constructor); // [Function: person][Function: person]
</code></pre>
<h2 id="tostring和typeof区别">toString和typeof区别</h2>
<p>之前一直不知道这两个有什么区别，所以这次好好研究一下，探索出来这样的关系
 {% asset_img toString_typeof.png %}</p>
<p>下面是一些测试例子</p>
<pre><code class="language-javascript">var toString = Object.prototype.toString;

let a= true;
console.log(typeof(a));//boolean
console.log(toString.call(a));//[object Boolean]

a=new Boolean(true);
console.log(typeof(a));//object 
console.log(toString.call(a));//[object Boolean]


a=new RegExp(&#39;ab+c&#39;, &#39;i&#39;);
console.log(a.source)//ab+c
console.log(a.global)//false
console.log(a.ignoreCase)//true
console.log(a.multiline)//false
console.log(a.lastIndex)//0

console.log(typeof(a));//object
console.log(toString.call(a));//[object RegExp]


function say() {
  console.log(&#39;hi&#39;);
};
a=say;
console.log(typeof(a));//function
console.log(toString.call(a));//[object Function]

a=[1,2,3,4,5];
(let i in a){
console.log(a[i])
}
console.log(typeof(a));//object
console.log(toString.call(a));//[object Array]

a=Symbol(&#39;foo&#39;);
console.log(typeof(a));//symbol
console.log(toString.call(a));//[object Symbol]

</code></pre>
<h2 id="数组使用for-in">数组使用for in</h2>
<p>for in函数中变量以字符串的形式出现，这时候在函数中操作a[x+1]的话是无效的，x+1会进行字符串拼接。</p>
<pre><code class="language-javascript">var a=[5,4,3,2,1];
        var x=0;
        console.log(typeof x);//number
        for (x in a) {
            console.log(&quot;a[&quot;+x+&quot;]: &quot;+a[x]);
            console.log(typeof x);//string
        }
        console.log(x);//4
        console.log(typeof x);//string
//output:
//        a[0]: 5
//        a[1]: 4
//        a[2]: 3
//        a[3]: 2
//        a[4]: 1</code></pre>

        </div>
    </div>
    
</body>
</html>